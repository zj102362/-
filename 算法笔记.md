#  不常用API

## HashMap

hashmap如何判断是否包含某一个元素？一定注意时containsKey()

```java
HashMap<Integer, String> map = new HashMap<>();
map.put(1, "one");
map.put(2, "two");

if (map.containsKey(1)) {
    System.out.println("Map contains key 1.");
}
```

hashmap获取值，如果不存在就为默认值

```java
map.put(sum, map.getOrDefault(sum, 0) + 1);
```

hashmap遍历

```java
for(Integer key : map.keySet()){
    int[] arr = new int[2];
    arr[0] = key;
    arr[1] = map.get(key);
    queue.offer(arr);
}
```

## 字符串

如何去除字符串前后的空格？

```java
s.trim()
```

判断字符串是否以某个字符串开头，切记是start**s**With()()

```java
str.startsWith("0")
```

## 堆栈

栈的使用

```java
Stack<Integer> a = new Stack<>();
a.push(x);
a.pop();
a.peek();
```

队列的使用

```java
LinkedList<Integer> queue = new LinkedList<>();
queue1.offer(x);
queue1.poll();
queue1.peek();
```

## 队列

优先级队列使用

```java
PriorityQueue<int[]> queue = new PriorityQueue<>((o1,o2) -> o2[1] - o1[1]);
```

## StringBuilder

移除元素

```java
StringBuilder sb = new StringBuilder("Hello!");
sb.deleteCharAt(sb.length() - 1); // 移除最后一个字符
```

## for循环

```java
for(int i = x-1, j = y-1; i >= 0 && j >= 0; i--,j--){   //正确
```

```java
for(int i = x-1, int j = y-1; i >= 0 && j >= 0; i--,j--){    //错误
```

for循环定义只能用一次，保证类型相同

## List

一维数组转列表

```java
自己for循环吧
```

二维数组转列表

```java
list.toArray(new int[people.length][]);
```

排序

```java
Arrays.sort(people,(a,b) -> {
    if(b[0] == a[0])
        return a[1] - b[1];
    return b[0] - a[0];
});
```

如果位置0元素相同，那么就用位置1排序。

几个数字转List（三数之和）

```java
List<Integer> t = new ArrayList<>(Arrays.asList(nums[k],nums[i],nums[j]));
```

## Integer

比较大小

```java
Integer.compare(a[0], b[0])
```

# Java Scanner 类

## **读取字符串**

```java
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {

        Scanner scanner = new Scanner(System.in);
        //读取一行字符串，包括空格。
        String name = scanner.nextLine();
        System.out.println(name);

        //读取下一个单词（以空格或换行符分隔）。
        String s = scanner.next();
        System.out.println(s);
        
    }
}
```

## **读取基本类型**

```java
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {

        Scanner scanner = new Scanner(System.in);
        //nextInt()：读取一个整数。
        int a = scanner.nextInt();
        System.out.println(a);
        //nextDouble()：读取一个双精度浮点数。
        double b = scanner.nextDouble();
        System.out.println(b);
        //nextBoolean()：读取一个布尔值。
        boolean c = scanner.nextBoolean();
        System.out.println(c);
        
    }
}
```

## 分隔符

### 默认分隔符

Scanner类默认使用空白字符（如空格、制表符、换行符等）作为分隔符。这意味着next()方法会读取下一个以空白字符分隔的单词。

你可以使用`useDelimiter()`方法来自定义分隔符。

### **自定义分隔符**

你可以使用`useDelimiter()`方法来自定义分隔符。

```java
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {

        Scanner scanner = new Scanner(System.in);
        scanner.useDelimiter(",");

        while(scanner.hasNext()) {
            int a = scanner.nextInt();
            System.out.println(a);
        }

    }
}
```

## **获取整型数组**

```java
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {

        Scanner scanner = new Scanner(System.in);
        String str = scanner.nextLine();
        String[] s = str.split(",");
        int[] nums= new int[s.length];
        for(int i=0;i<s.length;i++){
            nums[i]= Integer.parseInt(s[i]);
        }
    }
}
```

nextLine();吞空格问题

```java
一、使用next();
int a = input.nextInt();
int b = input.nextInt();
String s = input.next();
二、提前吞掉空格，防止后面吞掉
int a = input.nextInt();
int b = input.nextInt();
input.nextLine();
String s = input.nextLine();
```

## [A+B(1)](https://ac.nowcoder.com/acm/contest/5652/A)

![image-20240914142039734](算法笔记.assets/image-20240914142039734.png)

## [A+B(2)](https://ac.nowcoder.com/acm/contest/5652/B)

![image-20240914142029777](算法笔记.assets/image-20240914142029777.png)

## [A+B(3)](https://ac.nowcoder.com/acm/contest/5652/C)

![image-20240914142355636](算法笔记.assets/image-20240914142355636.png)

## [A+B(4)](https://ac.nowcoder.com/acm/contest/5652/D)















# 数组

## 704. 二分查找

https://leetcode.cn/problems/binary-search/

![image-20240912205739837](算法笔记.assets/image-20240912205739837.png)

```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0,right = nums.length-1;
        int mid;
        while(left <= right){
            mid = (left + right) >>1;
            if(nums[mid] == target)
                return mid;
            else if(nums[mid] > target)
                right = mid - 1;
            else if(nums[mid] < target)
                left = mid + 1;
        }
        return -1;
    }
}
```

##  27. 移除元素

[27. 移除元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-element/description/)

![image-20240912210457246](算法笔记.assets/image-20240912210457246.png)

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int left = 0;
        int right = 0;
        for(; right < nums.length; right++){
            if(nums[right] != val) nums[left++] = nums[right];
        }
        return left;
    }
}
```

快慢指针法

## 977.有序数组的平方

[977. 有序数组的平方 - 力扣（LeetCode）](https://leetcode.cn/problems/squares-of-a-sorted-array/)

![image-20240912211414822](算法笔记.assets/image-20240912211414822.png)

```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        int left = 0;
        int right = nums.length-1;
        int[] arr = new int[nums.length];
        int k = nums.length-1;
        while(left <= right){
            if(nums[left] * nums[left] > nums[right] * nums[right]){
                arr[k--] = nums[left] * nums[left];
                left++;
            }else{
                arr[k--] = nums[right] * nums[right];
                right--;
            }
        }
        return arr;
    }
}
```

双指针法，两边指针

##  209.长度最小的子数组

[209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

![image-20240912212515420](算法笔记.assets/image-20240912212515420.png)

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int left = 0;
        int sum = 0;
        int count = Integer.MAX_VALUE;

        for(int right = 0; right < nums.length; right++){
            sum += nums[right];
            while(sum >= target && left <= right){
                count = Math.min(right - left + 1,count);
                sum-=nums[left];
                left++;
            }
        }

        return count == Integer.MAX_VALUE ? 0 : count;
    }
}
```

快慢指针，for循环的快指针嵌套while循环的慢指针

## 59.螺旋矩阵II

[59. 螺旋矩阵 II - 力扣（LeetCode）](https://leetcode.cn/problems/spiral-matrix-ii/description/)

![image-20240912215025240](算法笔记.assets/image-20240912215025240.png)

```java
class Solution {
    public int[][] generateMatrix(int n) {
        int[][] nums = new int[n][n];
        int count = 0;
        int x = 0,y = 0;
        int i = 1;
        while(count < n/2){
            //从左到右
            for(; y <  n-count - 1; y++){
                nums[x][y] = i++;
            }
            //从上到下
            for(; x < n-count - 1; x++){
                nums[x][y] = i++;
            }
            //从右到左
            for(;y > count; y--){
                nums[x][y] = i++;
            }
            //从下到上
            for(;x > count; x--){
                nums[x][y] = i++;
            }
            count++;
            x++;
            y++;
        }
        if(n % 2 != 0) nums[n/2][n/2] = i;
        return nums;
    }
}
```

一定要注意，第一个循环x不动，y增加，因为这个问题耽误了很久时间！！！

## 58. 区间和⭐

[58. 区间和（第九期模拟笔试） (kamacoder.com)](https://kamacoder.com/problempage.php?pid=1070)

![image-20240922135556565](算法笔记.assets/image-20240922135556565.png)

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int[] nums = new int[n];
        for(int i = 0; i < n; i++){
            nums[i] = in.nextInt();
        }
        int[] result = new int[n];
        result[0] = nums[0];
        for(int i = 1; i < n; i++){
            result[i] = result[i-1] + nums[i] ;
        }

        while(in.hasNext()){
            int start = in.nextInt();
            int end = in.nextInt();
            if(start == 0)
                System.out.println(result[end]);
            else{
                System.out.println(result[end] - result[start-1]);
            }
        }
    }
}
```

## 44. 开发商购买土地

[44. 开发商购买土地（第五期模拟笔试） (kamacoder.com)](https://kamacoder.com/problempage.php?pid=1044)

![image-20240922143706465](算法笔记.assets/image-20240922143706465.png)

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int m = in.nextInt();
        int[][] nums = new int[n][m];
        int[] nhang = new int[n];
        int[] mlie = new int[m];
        int sum = 0;
        //输入的同时计算前缀和
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                nums[i][j] = in.nextInt();
                nhang[i] +=  nums[i][j];
                mlie[j] += nums[i][j];
                sum += nums[i][j];
            }
        }
        //计算前缀和
        for(int i = 1; i < n; i++){
            nhang[i] += nhang[i-1];
        }
        for(int i = 1; i < m; i++){
            mlie[i] += mlie[i-1];
        }

        int min = Integer.MAX_VALUE;
        for(int i = 0; i < n; i++){
            min = Math.min(min, Math.abs(sum - 2 * nhang[i]));
        }
        for(int i = 0; i < m; i++){
            min = Math.min(min,Math.abs(sum - 2 * mlie[i]));
        }
        System.out.println(min);
    }
}

```

# 链表

## 203.移除链表元素

[203. 移除链表元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-linked-list-elements/description/)

![image-20240912215507643](算法笔记.assets/image-20240912215507643.png)

```java
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        while(head != null && head.val == val) head = head.next;
        if(head == null) return head;

        ListNode p = head;
        while(p.next != null){
            if(p.next.val == val){
                p.next = p.next.next;
            }else{
                p = p.next;
            }
        }

        return head;
    }
}
```

## 707.设计链表

![image-20240922151159487](算法笔记.assets/image-20240922151159487.png)

```java
class ListNode{
    int val;
    ListNode next;
}

class MyLinkedList {
    ListNode xuniHead;
    int len;

    public MyLinkedList() {
        xuniHead = new ListNode();
        len = 0;
    }
    
    public int get(int index) {
        if(index > len -1) return -1;
        ListNode p = xuniHead;
        for(int i = 0; i < index+1; i++){
            p = p.next;
        }
        return p.val;
    }
    
    public void addAtHead(int val) {
        ListNode s = new ListNode();
        s.val = val;
        s.next = xuniHead.next;
        xuniHead.next = s;
        len++;
    }
    
    public void addAtTail(int val) {
        ListNode s = new ListNode();
        s.val = val;
        ListNode p = xuniHead;
        for(int i = 0; i < len; i++){
            p = p.next;
        }
        p.next = s;
        len++;
    }
    
    public void addAtIndex(int index, int val) {
        if(index > len) return;
        ListNode s = new ListNode();
        s.val = val;
        ListNode p = xuniHead;
        for(int i = 0; i < index; i++){
            p = p.next;
        }
        s.next = p.next;
        p.next = s;
        len++;
    }
    
    public void deleteAtIndex(int index) {
        if(index > len -1) return;
        ListNode p = xuniHead;
        for(int i = 0; i < index; i++){
            p = p.next;
        }
        p.next = p.next.next;
        len--;
    }
}

```

注意要设置一个虚拟头节点

##  206.反转链表

[206. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list/description/)

![image-20240912222610420](算法笔记.assets/image-20240912222610420.png)

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head == null || head.next == null) return head;
        ListNode p = head;
        ListNode q = head.next;
        ListNode r;
        p.next = null;//防止第一个节点成环
        while(q != null){
            r = q.next;
            q.next = p;
            p = q;
            q = r;
        }
        return p;
    }
}
```

三个节点，前两个节点反转指针，最后一个节点记录q的下一个节点位置

## 24. 两两交换链表中的节点

[24. 两两交换链表中的节点 - 力扣（LeetCode）](https://leetcode.cn/problems/swap-nodes-in-pairs/description/)

![image-20240912225817907](算法笔记.assets/image-20240912225817907.png)

```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        if(head == null || head.next == null) return head;
        ListNode xuniHead = new ListNode();
        xuniHead.next = head;
        ListNode q;
        ListNode p = xuniHead;
        while(p.next!=null && p.next.next!=null){
            q = p.next;
            p.next = q.next;
            q.next = p.next.next;
            p.next.next = q;

            p = q;
        }

        return xuniHead.next;
    }
}
```

创建一个虚拟头，加双指针，会方便许多

## 19.删除链表的倒数第N个节点

[19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/)

![image-20240912230352283](算法笔记.assets/image-20240912230352283.png)

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode xuniHead = new ListNode();
        xuniHead.next = head;

        ListNode left = xuniHead;
        ListNode right = xuniHead;
        for(int i = 0; i < n; i++)
            right = right.next;
        while(right.next != null){
            left = left.next;
            right = right.next;
        }
        left.next = left.next.next;

        return xuniHead.next;
    }
}
```

设置虚拟头，然后快慢指针法，快指针先移动n次

## 面试题 02.07. 链表相交

[面试题 02.07. 链表相交 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/)

![image-20240912231014886](算法笔记.assets/image-20240912231014886.png)

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode p = headA;
        ListNode q = headB;
        int lenA = 0;
        int lenB = 0;
        while(p != null){
            lenA++;
            p = p.next;
        }
        while(q != null){
            lenB++;
            q = q.next;
        }
        p = headA;
        q = headB;
        if(lenA > lenB){
            int step = lenA - lenB;
            for(int i = 0; i < step; i++){
                p = p.next;
            }
        }else{
            int step = lenB - lenA;
            for(int i = 0; i < step; i++){
                q = q.next;
            }
        }
        while(p != null && p != q){
            p = p.next;
            q = q.next;
        }
        
        return p == q ? p : null;
    }
}
```

先计算长度，比较长的链表先走step次。

##  142.环形链表II⭐

[142. 环形链表 II - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-cycle-ii/description/)

![image-20240912235208451](算法笔记.assets/image-20240912235208451.png)

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode fast = head, slow = head;
        while (true) {
            if (fast == null || fast.next == null) return null;
            fast = fast.next.next;
            slow = slow.next;
            if (fast == slow) break;
        }
        //一言以蔽之，相遇之处和链表头距离环入口距离相等
        fast = head;
        while (slow != fast) {
            slow = slow.next;
            fast = fast.next;
        }
        return fast;
    }
}

```

快指针一次走两步，慢指针一次走一步，到达相遇点以后，有一个指针回到头节点，然后两个指针同时往下走，相遇点就是入口。

![image-20240913000104896](算法笔记.assets/image-20240913000104896.png)

一言以蔽之，相遇之处和链表头距离环入口距离相等

# 哈希表

## 242.有效的字母异位词

[242. 有效的字母异位词 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-anagram/description/)

![image-20240913133257446](算法笔记.assets/image-20240913133257446.png)

```java
class Solution {
    public boolean isAnagram(String s, String t) { 
        if(s.length() != t.length()) return false;

        char[] nums = new char[26];
        for(int i = 0; i < s.length(); i++){
            nums[s.charAt(i) - 'a']++;
        }
        for(int i = 0; i < s.length(); i++){
            nums[t.charAt(i) - 'a']--;
        }
        for(int i = 0; i < 26; i++){
            if(nums[i] != 0) return false;
        }
        return true;
    }
}
```

三个循环解决问题，用一个字母数组存放每个字母个数。

##  349. 两个数组的交集

[349. 两个数组的交集 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-arrays/description/)

![image-20240913134917026](算法笔记.assets/image-20240913134917026.png)

```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        Set<Integer> set1 = new HashSet<>();
        Set<Integer> set2 = new HashSet<>();

        for(int i = 0; i < nums1.length; i++){
            set1.add(nums1[i]);
        }
        for(int i = 0; i < nums2.length; i++){
            if(set1.contains(nums2[i])) set2.add(nums2[i]);
        }
        int[] result = new int[set2.size()];
        int i = 0;
        for(int k : set2){
            result[i++] = k;
        }
        return result;
    }
}
```

使用两个set，第一个用于存放数组1，第二个用于遍历数组2的时候判断是否时交集，是的话就放第二个set中

## 第202题. 快乐数

[202. 快乐数 - 力扣（LeetCode）](https://leetcode.cn/problems/happy-number/description/)

![image-20240913140028861](算法笔记.assets/image-20240913140028861.png)

```java
class Solution {
    public boolean isHappy(int n) {
        Set<Integer> set = new HashSet<>();
        int sum = 0;
        int i;
        while(true){
            while(n != 0){
                i = n % 10;
                n = n / 10;
                sum += i * i;
            }
            if(sum == 1){
                return true;
            }else if(set.contains(sum)){
                return false;
            }else{
                set.add(sum);
            }
            n = sum;
            sum = 0;
        }

    }
}
```

这道题的关键在于，在循环求sum过程中，一旦重复说明必定不是快乐数，所以可以把循环过程中的sum放入set中，以后判断是否重复，用两个while循环判断，外循环判断sum，内循环计算sum。

## 1. 两数之和

[1. 两数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/two-sum/description/)

![image-20240922160152050](算法笔记.assets/image-20240922160152050.png)

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i = 0; i < nums.length; i++){
            if(map.containsKey(target-nums[i]) && map.get(target-nums[i]) != i)
                return new int[]{i,map.get(target-nums[i])};
            map.put(nums[i],i);
        }
        return null;
    }
}
```

用一个HashMap，key是数字，value是下标，一定注意map的contain方法是containsKey！！！！！

## 第454题.四数相加II

[454. 四数相加 II - 力扣（LeetCode）](https://leetcode.cn/problems/4sum-ii/description/)

![image-20240913143011313](算法笔记.assets/image-20240913143011313.png)

前两个数放到map中，key是两数值和，value是次数。两个双层循环。

## 383. 赎金信

[383. 赎金信 - 力扣（LeetCode）](https://leetcode.cn/problems/ransom-note/description/)

![image-20240922161145062](算法笔记.assets/image-20240922161145062.png)

```java
class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
        int[] nums = new int[26];
        for(int i = 0; i < magazine.length(); i++){
            nums[magazine.charAt(i) - 'a']++;
        }
        for(int i = 0; i < ransomNote.length(); i++){
            nums[ransomNote.charAt(i) - 'a']--;
            if(nums[ransomNote.charAt(i) - 'a'] < 0)
                return false;
        }
        return true;
    }
}
```

和前面有效的字母异位词很像，三次循环，第一次循环放值，第二次取值并判断，因为字母固定，所以可以用int数组代替hash。

## 第15题. 三数之和⭐⭐

[15. 三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum/description/)

![image-20240922171036188](算法笔记.assets/image-20240922171036188.png)

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> list = new ArrayList<>();
        Arrays.sort(nums);
        for(int i = 0; i < nums.length - 2; i++){
            if(nums[i] + nums[i+1] + nums[i+2] > 0) break;
            if(i != 0 && nums[i] == nums[i-1]) continue;
            int left = i + 1;
            int right = nums.length - 1;
            while(left < right){
                int sum = nums[i] + nums[left] + nums[right];
                if(sum < 0)
                    left++;
                else if(sum > 0)
                    right--;
                else{
                    list.add(new ArrayList<>(Arrays.asList(nums[i],nums[left],nums[right])));
                    while(left < right && nums[left] == nums[left+1]) left++;
                    while(left < right && nums[right] == nums[right-1]) right--;
                    left++;
                    right--;
                }
            }
        }
        return list;
    }
}
```

三数之和，不用hash！！！用三指针法， 先排序，然后，后面两个指针往中间移动。

## 第18题. 四数之和⭐⭐

[18. 四数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/4sum/description/)

![image-20240922165136932](算法笔记.assets/image-20240922165136932.png)

```java
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> list = new ArrayList<>();
        Arrays.sort(nums);

        for(int i = 0; i < nums.length-3; i++){
            if((long)nums[i] + nums[i+1] + nums[i+2] + nums[i+3]> target) break;
            if(i != 0 && nums[i] == nums[i-1]) continue;
            for(int j = i+1; j < nums.length-2; j++){
                if((long)nums[i] + nums[j] + nums[j+1] + nums[j+2]> target) break;
                if(j != i+1 && nums[j] == nums[j-1]) continue;

                int m = j+1;
                int n = nums.length-1;

                while(m < n){
                    int sum = nums[i] + nums[j] + nums[m] + nums[n];
                    if(sum < target){
                        m++;
                    }else if(sum > target){
                        n--;
                    }else{
                        List<Integer> t = new ArrayList(Arrays.asList(nums[i],nums[j],nums[m],nums[n]));
                        list.add(t);
                        while(m < n && nums[m+1] == nums[m]) m++;
                        while(m < n && nums[n-1] == nums[n]) n--;
                        m++;
                        n--;
                    }
                }

            }
        }

        return list;
    }
}
```

还是用双指针法，注意！！！有几个过不了的案例，是因为超出int范围了，要转为long!!!,要注意

# 字符串

## 344.反转字符串

[344. 反转字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-string/)

![image-20240913154550189](算法笔记.assets/image-20240913154550189.png)

```java
class Solution {
    public void reverseString(char[] s) {
        int left = 0;
        int right = s.length-1;
        while(left < right){
            char temp = s[left];
            s[left] = s[right];
            s[right] = temp;
            left++;
            right--;
        }
    }
}
```

## 541. 反转字符串II⭐

[541. 反转字符串 II - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-string-ii/description/)

![image-20240913163340436](算法笔记.assets/image-20240913163340436.png)

```java
class Solution {
    public String reverseStr(String s, int k) {
        char[] str = s.toCharArray();

        for(int i = 0; i < s.length(); i += 2*k){
            int j = Math.min(i + k - 1,s.length()-1);
            swap(str,i,j);
        }
        
        return new String(str);
    }

    public static void swap(char[] str, int left, int right){
        while(left < right){
            char temp = str[left];
            str[left] = str[right];
            str[right] = temp;
            left++;
            right--;
        }
    }
}
```

for循环套swap函数，注意j的值为int j = **Math.min(i + k - 1,s.length()-1);**

## 替换数字

[54. 替换数字（第八期模拟笔试） (kamacoder.com)](https://kamacoder.com/problempage.php?pid=1064)

![image-20240923095938235](算法笔记.assets/image-20240923095938235.png)

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner in = new Scanner(System.in);
        String str = in.nextLine();
        StringBuilder sb = new StringBuilder();
        for(int i = 0; i < str.length(); i++){
            char c = str.charAt(i);
            if(c >= '0' && c <= '9'){
                sb.append("number");
            }else{
                sb.append(c);
            }
        }
        System.out.println(new String(sb));
    }
}


```

## 151.翻转字符串里的单词⭐

[151. 反转字符串中的单词 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-words-in-a-string/)

![image-20240913170314959](算法笔记.assets/image-20240913170314959.png)

```java
class Solution {
    public String reverseWords(String s) {
        char[] str = delSpace(s.trim()).toCharArray();
        swap(str,0,str.length-1);

        for(int i = 0; i < str.length;){
            int j = i+1;
            while(j < str.length && str[j] != ' ') j++;
            swap(str,i,j-1);
            i = j+1;
        }
        return new String(str);
    }
    //去除多余空格
    public static String delSpace(String s){
        StringBuffer sb = new StringBuffer();
        int i = 0;
        for(; i < s.length(); i++){
            if(s.charAt(i) == ' '){
                sb.append(' ');
                while(s.charAt(i+1) == ' ') i++;
            }else{
                sb.append(s.charAt(i));
            }
        }
        return new String(sb);
    }
    //反转字符串
    public static void swap(char[] str,int left, int right){
        while(left < right){
            char temp = str[left];
            str[left] = str[right];
            str[right] = temp;
            left++;
            right--;
        }
    }
}
```

第一步：去除字符串前后的空格和重点多余的空格

第二步：反转整个字符串

第三步：逐个单词反转

## 右旋字符串

[55. 右旋字符串（第八期模拟笔试） (kamacoder.com)](https://kamacoder.com/problempage.php?pid=1065)

![image-20240923102915376](算法笔记.assets/image-20240923102915376.png)

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner in = new Scanner(System.in);
        int k = in.nextInt();
        in.nextLine();
        String str = in.nextLine();

        char[] res = str.toCharArray();
        while(k-- > 0){
            char temp = res[res.length - 1];
            for(int i = res.length - 1; i > 0; i--){
                res[i] = res[i-1];
            }
            res[0] = temp;
        }
        System.out.println(new String(res));
    }
}


```

##  28. 实现 strStr()⭐⭐

[28. 找出字符串中第一个匹配项的下标 - 力扣（LeetCode）](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/)

![image-20240913215030867](算法笔记.assets/image-20240913215030867.png)

```java
class Solution {
    //前缀表（不减一）Java实现
    public int strStr(String haystack, String needle) {
        if (needle.length() == 0) return 0;
        int[] next = new int[needle.length()];
        getNext(next, needle);

        int j = 0;
        for (int i = 0; i < haystack.length(); i++) {
            while (j > 0 && needle.charAt(j) != haystack.charAt(i)) 
                j = next[j - 1];
            if (needle.charAt(j) == haystack.charAt(i)) 
                j++;
            if (j == needle.length()) 
                return i - needle.length() + 1;
        }
        return -1;

    }
    
    private void getNext(int[] next, String s) {
        int j = 0;
        next[0] = 0;
        for (int i = 1; i < s.length(); i++) {
            while (j > 0 && s.charAt(j) != s.charAt(i)) 
                j = next[j - 1];
            if (s.charAt(j) == s.charAt(i)) 
                j++;
            next[i] = j; 
        }
    }
}
```

## 459.重复的子字符串⭐

[459. 重复的子字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/repeated-substring-pattern/description/)

![image-20240913221417340](算法笔记.assets/image-20240913221417340.png)

```java
class Solution {
    public boolean repeatedSubstringPattern(String s) {
        String str = s + s;
        return str.substring(1,str.length()-1).contains(s);
    }
}
```

![image-20240913221411157](算法笔记.assets/image-20240913221411157.png)

# 栈与队列

## 232.用栈实现队列⭐

[232. 用栈实现队列 - 力扣（LeetCode）](https://leetcode.cn/problems/implement-queue-using-stacks/description/)

![image-20240913222223261](算法笔记.assets/image-20240913222223261.png)

```java
class MyQueue {
    Stack<Integer> a;
    Stack<Integer> b;

    public MyQueue() {
        a = new Stack<>();
        b = new Stack<>();
    }
    
    public void push(int x) {
        a.push(x);
    }
    
    public int pop() {
        if(b.isEmpty()){
            while(!a.isEmpty()){
                b.push(a.pop());
            }
        }
        return b.pop();
    }
    
    public int peek() {
        if(b.isEmpty()){
            while(!a.isEmpty()){
                b.push(a.pop());
            }
        }
        return b.peek();
    }
    
    public boolean empty() {
        if(a.isEmpty() && b.isEmpty()) return true;
        return false;
    }
}
```

## 225. 用队列实现栈⭐

[225. 用队列实现栈 - 力扣（LeetCode）](https://leetcode.cn/problems/implement-stack-using-queues/description/)

![image-20240913224420517](算法笔记.assets/image-20240913224420517.png)

```java
class MyStack {
    LinkedList<Integer> queue1;
    LinkedList<Integer> queue2;
    public MyStack() {
        queue1 = new LinkedList<>();
        queue2 = new LinkedList<>();
    }
    
    public void push(int x) {
        queue2.offer(x);
        while(!queue1.isEmpty()){
            queue2.offer(queue1.poll());
        }
        LinkedList<Integer> temp = queue1;
        queue1 = queue2;
        queue2 = temp;
    }
    
    public int pop() {
        return queue1.poll();
    }
    
    public int top() {
        return queue1.peek();
    }
    
    public boolean empty() {
        return queue1.isEmpty();
    }
}
```

**用两个队列que1和que2实现队列的功能，que2其实完全就是一个备份的作用**，把que1最后面的元素以外的元素都备份到que2，然后弹出最后面的元素，再把q1和q2互换，主队列变从队列，从队列变主队列。

##  20. 有效的括号

[20. 有效的括号 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-parentheses/description/)

![image-20240913225544305](算法笔记.assets/image-20240913225544305.png)

```java
class Solution {
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();

        for(int i = 0; i < s.length(); i++){
            if(s.charAt(i) == '(' || s.charAt(i) == '[' || s.charAt(i) == '{')
                stack.push(s.charAt(i));

            if(s.charAt(i) == ')'){
                if(stack.isEmpty() || stack.pop() != '(') return false;
            }
            if(s.charAt(i) == ']'){
                if(stack.isEmpty() || stack.pop() != '[') return false;
            }
            if(s.charAt(i) == '}'){
                if(stack.isEmpty() || stack.pop() != '{') return false;
            }
        }
        if(stack.isEmpty()) return true;
        return false;
    }
}
```

## 1047. 删除字符串中的所有相邻重复项

[1047. 删除字符串中的所有相邻重复项 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/)

![image-20240913230107343](算法笔记.assets/image-20240913230107343.png)

```java
class Solution {
    public String removeDuplicates(String s) {
        Stack<Character> stack = new Stack<>();

        for(int i = 0; i < s.length(); i++){
            if(!stack.isEmpty() && s.charAt(i) == stack.peek()){
                stack.pop();
            }else{
                stack.push(s.charAt(i));
            }
        }
        char[] str = new char[stack.size()];
        for(int i = str.length-1; i >= 0; i--){
            str[i] = stack.pop();
        }
        return new String(str);
    }
}
```

栈

## 150. 逆波兰表达式求值

![image-20240913230914919](算法笔记.assets/image-20240913230914919.png)

```java
class Solution {
    public int evalRPN(String[] tokens) {
        Stack<Integer> stack = new Stack<>();
        for(int i = 0; i < tokens.length; i++){
            if(tokens[i].equals("+")){
                int a = stack.pop();
                int b =  stack.pop();
                stack.push(a+b);
            }else if(tokens[i].equals("-")){
                int a = stack.pop();
                int b =  stack.pop(); 
                stack.push(b-a);
            }else if(tokens[i].equals("*")){
                int a = stack.pop();
                int b =  stack.pop();
                stack.push(a*b);
            }else if(tokens[i].equals("/")){
                int a = stack.pop();
                int b =  stack.pop();
                stack.push(b/a);
            }else{
                System.out.println(tokens[i]);
                stack.push(Integer.parseInt(tokens[i]));
            }
        }
        return stack.pop();
    }
}
```

切记！字符串判等要用equals

##  239. 滑动窗口最大值

[239. 滑动窗口最大值 - 力扣（LeetCode）](https://leetcode.cn/problems/sliding-window-maximum/description/)

![image-20240913233241151](算法笔记.assets/image-20240913233241151.png)

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int[] result = new int[nums.length - k + 1];
        LinkedList<Integer> list = new LinkedList<>();

        for(int i =  0; i < k; i++){
            while(!list.isEmpty() && list.getLast() < nums[i]) 
                list.removeLast();
            list.addLast(nums[i]);
        }
        result[0] = list.getFirst();

        for(int i = k; i < nums.length; i++){
            while(!list.isEmpty() && list.getLast() < nums[i]) 
                list.removeLast();
            list.addLast(nums[i]);

            if(list.getFirst() == nums[i-k])
                list.removeFirst();
            result[i-k+1] = list.getFirst();
        }
        return result;
    }
}
```

<img src="算法笔记.assets/image-20240913233349019.png" alt="image-20240913233349019" style="zoom:50%;" />

想像成在飞机上往下看,如果有更高的山峰出现在视野中,那么这座山之前的所有山都可以去掉了,因为他们肯定更先消失且最高峰不可能是他们,使用双端队列(递减)实现,进值一个个从右边进入(进入前出队比当前值小的),取值一个个从左边取(不出队只是取值)

## 347.前 K 个高频元素⭐

![image-20240914001457355](算法笔记.assets/image-20240914001457355.png)

```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        int[] result = new int[k];
        PriorityQueue<int[]> queue = new PriorityQueue<>((o1,o2) -> o2[1] - o1[1]);
        Map<Integer,Integer> map = new HashMap<>();//计算频次
        for(int i = 0; i < nums.length; i++){
            map.put(nums[i],map.getOrDefault(nums[i],0)+1);
        }

        for(Integer key : map.keySet()){
            int[] arr = new int[2];
            arr[0] = key;
            arr[1] = map.get(key);
            queue.offer(arr);
        }
        
        for(int i = 0; i < k; i++){
            result[i] = queue.poll()[0];
        }

        return result;
    }
}
```

一个HashMap计算频次，一个PriorityQueue比较。

# 二叉树

## 二叉树：总结篇

### 二叉树的遍历方式

前序遍历（中左右）
 ```java
 使用栈，每次出栈是先入栈右子树，再入栈左子树
 ```

后序遍历（左右中）
 ```java
 使用栈，每次出栈是先入栈左子树，然后入栈右子树，这样就是中右左的顺序，然后每次插入是list.add(0,p.val)就是左右中
 ```

中序遍历
 ```java
 使用栈，条件是 while(!stack.isEmpty() || p != null){}，p一直往坐下找，找不到就出栈，然后入栈出栈元素的右子树
 ```

层序遍历
```java
使用队列（LinkedList）！！！
```

### 求二叉树的属性

[二叉树：是否对称](https://programmercarl.com/0101.对称二叉树.html)

```java
后序，比较的是根节点的左子树与右子树是不是相互翻转
```

[二叉树：求最大深度](https://programmercarl.com/0104.二叉树的最大深度.html)

```java
 return Math.max(left,right)+1;
```

[二叉树：求最小深度](https://programmercarl.com/0111.二叉树的最小深度.html)

```java
if(left == 0 || right == 0)
    return left + right + 1;
return Math.min(left,right) + 1;
```

[二叉树：求有多少个节点](https://programmercarl.com/0222.完全二叉树的节点个数.html)

```java
if(root == null) return 0;
return countNodes(root.left) + countNodes(root.right) + 1;
```

[二叉树：是否平衡](https://programmercarl.com/0110.平衡二叉树.html)

```java
int left = isTrue(root.left);
...
int right = isTrue(root.right);
...
if(Math.abs(left-right) > 1)
    return -1;
...
```

[二叉树：找所有路径](https://programmercarl.com/0257.二叉树的所有路径.html)

回溯

```java
List<String> list = new ArrayList<>();
List<Integer> path = new ArrayList<>();
```

[二叉树：求左叶子之和](https://programmercarl.com/0404.左叶子之和.html)

```java
if(root.left != null && root.left.left == null && root.left.right == null)
    return root.left.val + left + right;
else
    return left + right;
```

[二叉树：求左下角的值](https://programmercarl.com/0513.找树左下角的值.html)

```java
层序遍历找最后一行最左边
```

[二叉树：求路径总和](https://programmercarl.com/0112.路径总和.html)

```java
用一个sum进行类似回溯运算
```

### 二叉树的修改与构造

[翻转二叉树](https://programmercarl.com/0226.翻转二叉树.html)

```java
TreeNode temp = root.left;
root.left = root.right;
root.right = temp;
```

[构造二叉树](https://programmercarl.com/0106.从中序与后序遍历序列构造二叉树.html)

```java
root.left = build(inorder,postorder,inS,index-1,postS,postS + len-1);
root.right = build(inorder,postorder,index+1,inE,postS + len,postE-1);
return root;
```

[构造最大的二叉树](https://programmercarl.com/0654.最大二叉树.html)

```java
root.left = build(nums,start,index-1);
root.right = build(nums,index+1,end);
return root;
```

[合并两个二叉树](https://programmercarl.com/0617.合并二叉树.html)

```java
if(root1 == null) return root2;
if(root2 == null) return root1;

root1.val += root2.val;
root1.left = merge(root1.left,root2.left);
root1.right = merge(root1.right,root2.right);

return root1;
```

### 求二叉搜索树的属性（二叉搜索树中序遍历递归！！！）

[二叉搜索树中的搜索](https://programmercarl.com/0700.二叉搜索树中的搜索.html)

```java
while(root != null && root.val != val){
    if(val < root.val)
        root = root.left;
    else
        root = root.right;
}
return root;
```

[是不是二叉搜索树](https://programmercarl.com/0098.验证二叉搜索树.html)

```java
search(root.left);

if(pre != null && root.val <= pre.val)
    flag = false;
pre = root;

search(root.right);
```

[求二叉搜索树的最小绝对差](https://programmercarl.com/0530.二叉搜索树的最小绝对差.html)

```java
search(root.left);

if(pre != null) 
    min = Math.min(min,root.val - pre.val);
pre = root;

search(root.right);
```

[求二叉搜索树的众数](https://programmercarl.com/0501.二叉搜索树中的众数.html)

```java
TreeNode pre;
int maxCount = 1;
int curCount = 1;
List<Integer> list = new ArrayList<>();
```

[二叉搜索树转成累加树](https://programmercarl.com/0538.把二叉搜索树转换为累加树.html)

```java
search(root.right);

if(pre != null){
    root.val = root.val + pre.val;
}
pre = root;

search(root.left);
```

### 二叉树公共祖先问题

[二叉树的公共祖先问题](https://programmercarl.com/0236.二叉树的最近公共祖先.html)

```java
if(root == null || root == p || root == q)
    return root;

TreeNode left = lowestCommonAncestor(root.left,p,q);
TreeNode right = lowestCommonAncestor(root.right,p,q);

if(root == null && right == null)
    return null;
if(left == null)
    return right;
if(right == null)
    return  left;
return root;
```

[二叉搜索树的公共祖先问题](https://programmercarl.com/0235.二叉搜索树的最近公共祖先.html)

```java
if (root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);
if (root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);
return root;
```

二叉搜索树的修改与构造

[二叉搜索树中的插入操作](https://programmercarl.com/0701.二叉搜索树中的插入操作.html)

```java
TreeNode pre;
```

[二叉搜索树中的删除操作](https://programmercarl.com/0450.删除二叉搜索树中的节点.html)

```java
...单层删除逻辑

root.left = deleteNode(root.left,key);
root.right = deleteNode(root.right,key);

return root;
```

[修剪二叉搜索树](https://programmercarl.com/0669.修剪二叉搜索树.html)

```java
if(root.val < low)
    return trimBST(root.right,low,high);
if(root.val > high)
    return trimBST(root.left,low,high);

root.left = trimBST(root.left,low,high);
root.right = trimBST(root.right,low,high);

return root;
```

[构造二叉搜索树](https://programmercarl.com/0108.将有序数组转换为二叉搜索树.html)

```java
int mid = (start + end) / 2;
TreeNode root = new TreeNode(nums[mid]);
root.left = build(nums,start,mid-1);
root.right = build(nums,mid+1,end);

return root;
```

### 最后总结

- 涉及到二叉树的构造，无论普通二叉树还是二叉搜索树一定前序，都是先构造中节点。
- 求普通二叉树的属性，一般是后序，一般要通过递归函数的返回值做计算。
- 求二叉搜索树的属性，一定是中序了，要不白瞎了有序性了。

## 二叉树前中后序遍历（递归）

[144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)

![image-20240914081830173](算法笔记.assets/image-20240914081830173.png)

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        preorder(root,list);
        return list;
    }
    public static void preorder(TreeNode root,List<Integer> list ){
        if(root == null)
            return;
        
        list.add(root.val);
        preorder(root.left,list);
        preorder(root.right,list);
    }
}
```

[145. 二叉树的后序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-postorder-traversal/description/)

![image-20240914082137992](算法笔记.assets/image-20240914082137992.png)

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        postorder(root,list);
        return list;
    }
    public static void postorder(TreeNode root,List<Integer> list){
        if(root == null)
            return;
        postorder(root.left,list);
        postorder(root.right,list);
        list.add(root.val);
    }
}
```

[94. 二叉树的中序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-inorder-traversal/description/)

![image-20240914082342973](算法笔记.assets/image-20240914082342973.png)

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        inorder(root,list);
        return list;
    }
    public static void inorder(TreeNode root,List<Integer> list){
        if(root == null)
            return;
        inorder(root.left,list);
        list.add(root.val);
        inorder(root.right,list);
    }
}
```

## 二叉树前中后序遍历（迭代）⭐

[144. 二叉树的前序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-preorder-traversal/description/)

![image-20240914083332689](算法笔记.assets/image-20240914083332689.png)

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        if(root == null) return list;

        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);

        while(!stack.isEmpty()){
            TreeNode p = stack.pop();
            list.add(p.val);
            if(p.right != null) stack.push(p.right);
            if(p.left != null) stack.push(p.left);
        }

        return list;
    }
}
```

前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。

为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。

[145. 二叉树的后序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-postorder-traversal/description/)

![image-20240914084540556](算法笔记.assets/image-20240914084540556.png)

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        if(root == null) return list;

        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);

        while(!stack.isEmpty()){

            TreeNode p = stack.pop();
            list.add(p.val);

            if(p.left != null) stack.push(p.left);
            if(p.right != null) stack.push(p.right);

        }
        Collections.reverse(list);
        return list;
    }
}
```

再来看后序遍历，先序遍历是中左右，后序遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了，如下图：

![image-20240914084555566](算法笔记.assets/image-20240914084555566.png)

[94. 二叉树的中序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-inorder-traversal/description/)

![image-20240914085131471](算法笔记.assets/image-20240914085131471.png)

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        if(root == null) return list;

        Stack<TreeNode> stack = new Stack<>();
        TreeNode cur = root;
        while(cur!= null || !stack.isEmpty()){
            if(cur!=null){
                stack.push(cur);
                cur = cur.left;
            }else{
                TreeNode p = stack.pop();
                list.add(p.val);
                cur = p.right;
            }
        }

        return list;
    }
}
```

**在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。**

如果cur!=null就一直向左找，找不到就pop数据，并把cur指向pop出节点的右子树。

## 二叉树层序遍历	

- [102.二叉树的层序遍历(opens new window)](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

![image-20240914090505120](算法笔记.assets/image-20240914090505120.png)

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> list = new ArrayList<>();
        if(root == null) return list;

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            List<Integer> temp = new ArrayList<>();
            int len = queue.size();

            for(int i = 0; i < len; i++){
                TreeNode p = queue.poll();
                temp.add(p.val);
                
                if(p.left != null)  queue.offer(p.left);
                if(p.right != null)  queue.offer(p.right);
            }
            list.add(temp);
        }
        return list;
    }
}
```

用队列！！！

- [107.二叉树的层次遍历II(opens new window)](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)

![image-20240914091151028](算法笔记.assets/image-20240914091151028.png)

```java
class Solution {
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        List<List<Integer>> list = new ArrayList<>();
        if(root == null)
            return list;

        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);

        while(!queue.isEmpty()){
            List<Integer> temp = new ArrayList<>();
            int len = queue.size();

            for(int i = 0; i < len; i++){
                TreeNode p = queue.poll();
                temp.add(p.val);
                if(p.left != null) queue.offer(p.left);
                if(p.right != null) queue.offer(p.right);
            }

            list.add(0,temp);
        }

        return list;
    }
}
```

插入list的时候采用头插法即可，或者最后反转一下list

- [199.二叉树的右视图(opens new window)](https://leetcode.cn/problems/binary-tree-right-side-view/)

![image-20240914091652969](算法笔记.assets/image-20240914091652969.png)

```java
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        if(root == null) return list;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);

        while(!queue.isEmpty()){

            int len  = queue.size();
            for(int i = 0; i < len; i++){
                TreeNode p = queue.poll();
                if(p.left != null) queue.offer(p.left);
                if(p.right != null) queue.offer(p.right);
                if(i == len-1) list.add(p.val);
            }
            
        }

        return list;
    }
}
```

- [637.二叉树的层平均值(opens new window)](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)

![image-20240914092037734](算法笔记.assets/image-20240914092037734.png)

```java
class Solution {
    public List<Double> averageOfLevels(TreeNode root) {
        List<Double> list = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);

        while(!queue.isEmpty()){
            int len = queue.size();
            double sum = 0;
            for(int i = 0; i < len; i++){
                TreeNode p = queue.poll();
                sum += p.val;
                if(p.left != null) queue.offer(p.left);
                if(p.right != null) queue.offer(p.right);
            }
            list.add(sum/len);

        }
        return list;

    }
}
```

- [429.N叉树的层序遍历(opens new window)](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)

![image-20240914092513304](算法笔记.assets/image-20240914092513304.png)

```java
class Solution {
    public List<List<Integer>> levelOrder(Node root) {
        List<List<Integer>> list = new ArrayList<>();
        if(root == null) return list;
        Queue<Node> queue = new LinkedList<>();
        queue.offer(root);

        while(!queue.isEmpty()){
            int len = queue.size();
            List<Integer> temp = new ArrayList<>();
            for(int i = 0; i < len; i++){
                Node p = queue.poll();
                temp.add(p.val);
                for(Node n : p.children){
                    queue.offer(n);
                }
            }
            list.add(temp);
        }
        return list;
    }

}
```

- [515.在每个树行中找最大值(opens new window)](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)

![image-20240914092857213](算法笔记.assets/image-20240914092857213.png)

```java
class Solution {
    public List<Integer> largestValues(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        if(root == null) return list;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);

        while(!queue.isEmpty()){
            int len = queue.size();
            int max = Integer.MIN_VALUE;

            for(int i = 0; i < len; i++){
                TreeNode p = queue.poll();
                max = Math.max(max,p.val);
                if(p.left != null) queue.offer(p.left);
                if(p.right != null) queue.offer(p.right);
            }
            list.add(max);

        }
        return list;
    }
}
```

- [116.填充每个节点的下一个右侧节点指针(opens new window)](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)

![image-20240914093825759](算法笔记.assets/image-20240914093825759.png)

```java
class Solution {
    public Node connect(Node root) {
        if(root == null) return root;
        Queue<Node> queue = new LinkedList<>();
        queue.offer(root);

        while(!queue.isEmpty()){
            int len = queue.size();
            Node pre = queue.poll();
            if(pre.left != null) queue.offer(pre.left);
            if(pre.right != null) queue.offer(pre.right);
            
            for(int i  = 1; i < len; i++){
                Node cur = queue.poll();
                pre.next = cur;
                pre = cur;

                if(pre.left != null) queue.offer(pre.left);
                if(pre.right != null) queue.offer(pre.right);
            }
        }
        return root;
    }
}
```

- [117.填充每个节点的下一个右侧节点指针II(opens new window)](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)

![image-20240914094040992](算法笔记.assets/image-20240914094040992.png)

```java
class Solution {
    public Node connect(Node root) {
        if(root == null) return root;
        Queue<Node> queue = new LinkedList<>();
        queue.offer(root);

        while(!queue.isEmpty()){
            int len = queue.size();
            Node pre = queue.poll();
            if(pre.left != null) queue.offer(pre.left);
            if(pre.right != null) queue.offer(pre.right);
            
            for(int i  = 1; i < len; i++){
                Node cur = queue.poll();
                pre.next = cur;
                pre = cur;

                if(pre.left != null) queue.offer(pre.left);
                if(pre.right != null) queue.offer(pre.right);
            }
        }
        return root;
    }
}
```

- [104.二叉树的最大深度(opens new window)](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

![image-20240914094410307](算法笔记.assets/image-20240914094410307.png)

```java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null) return 0;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        int count = 0;
        while(!queue.isEmpty()){
            int len = queue.size();
            for(int i = 0; i < len; i++){
                TreeNode p = queue.poll();
                if(p.left != null) queue.offer(p.left);
                if(p.right != null) queue.offer(p.right);
            }
            count++;
        }
        return count;
    }
}
```

- [111.二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

![image-20240914094906120](算法笔记.assets/image-20240914094906120.png)

```java
class Solution {
    public int minDepth(TreeNode root) {
        if(root == null) return 0;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        
        int count = 0;
        while(!queue.isEmpty()){
            int len = queue.size();
            for(int i = 0; i < len; i++){
                TreeNode p = queue.poll();
                if(p.left != null) queue.offer(p.left);
                if(p.right != null) queue.offer(p.right);
                if(p.left == null && p.right == null) return ++count;
            }
            count++;
        }
        return count;
    }
}
```

## 226.翻转二叉树

[226. 翻转二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/invert-binary-tree/description/)

![image-20240914095126979](算法笔记.assets/image-20240914095126979.png)

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        reverse(root);
        return root;
    }

    public static void reverse(TreeNode root){
        if(root == null) return;

        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;

        reverse(root.left);
        reverse(root.right);
    }
}
```

##  101. 对称二叉树⭐

[101. 对称二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/symmetric-tree/description/)

![image-20240914100959888](算法笔记.assets/image-20240914100959888.png)

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return isRight(root.left,root.right);
    }

    public static boolean isRight(TreeNode left,TreeNode right){
        //递归出口
        if(left == null && right == null)
            return true;
        if(left == null || right == null)
            return false;
        if(left.val != right.val)
             return false;

        //单层递归逻辑 left.val == right.val的情况
        boolean out = isRight(left.left,right.right);//左
        boolean in = isRight(left.right,right.left);//右
        return out && in;//中
    }

}
```

## 104.二叉树的最大深度⭐

[104. 二叉树的最大深度 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/)

递归

```java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null)    return 0;

        int left = maxDepth(root.left);
        int right = maxDepth(root.right);
        
        return Math.max(left,right)+1;
    }
}
```

层次遍历

```java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null) return 0;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        int count = 0;
        while(!queue.isEmpty()){
            int len = queue.size();
            for(int i = 0; i < len; i++){
                TreeNode p = queue.poll();
                if(p.left != null) queue.offer(p.left);
                if(p.right != null) queue.offer(p.right);
            }
            count++;
        }
        return count;
    }
}
```

## 111.二叉树的最小深度⭐

递归

```java
class Solution {
    public int minDepth(TreeNode root) {
        return min(root);
    }

    public static int min(TreeNode root){
        if(root == null) return 0;

        int left = min(root.left);
        int right = min(root.right);

        if(left != 0 && right != 0)
            return Math.min(left,right)+1;
        else
            return left+right+1;
    }

}
```

层次遍历

```java
class Solution {
    public int minDepth(TreeNode root) {
        if(root == null) return 0;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        
        int count = 0;
        while(!queue.isEmpty()){
            int len = queue.size();
            for(int i = 0; i < len; i++){
                TreeNode p = queue.poll();
                if(p.left != null) queue.offer(p.left);
                if(p.right != null) queue.offer(p.right);
                if(p.left == null && p.right == null) return ++count;
            }
            count++;
        }
        return count;
    }
}
```

## 222.完全二叉树的节点个数

[222. 完全二叉树的节点个数 - 力扣（LeetCode）](https://leetcode.cn/problems/count-complete-tree-nodes/description/)

![image-20240923150859459](算法笔记.assets/image-20240923150859459.png)

```java
class Solution {
    int n = 0;
    public int countNodes(TreeNode root) {
        if(root == null) return 0;
        return countNodes(root.left) + countNodes(root.right) + 1;
    }
}
```

## 110.平衡二叉树⭐

[110. 平衡二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/balanced-binary-tree/description/)

![image-20240914105325087](算法笔记.assets/image-20240914105325087.png)

```java
class Solution {
    public boolean isBalanced(TreeNode root) {
        return deep(root) != -1;
    }

    public static int deep(TreeNode root){
        if(root == null) return 0;

        int left= deep(root.left);
        int right = deep(root.right);
        if(left == -1 || right == -1)
            return -1;
        if(Math.abs(left-right) > 1)
            return -1;
        return Math.max(left,right)+1;
    }

}
```

还是求最大高度，但是高度差>1的时候返回-1，判定为非平衡树。

## 257. 二叉树的所有路径⭐⭐

![image-20240914111847720](算法笔记.assets/image-20240914111847720.png)

```java
class Solution {
    List<String> list = new ArrayList<>();
    List<Integer> path = new ArrayList<>();//回溯

    public List<String> binaryTreePaths(TreeNode root) {
        backTracing(root);
        return list;
    }

    public void backTracing(TreeNode root){
        path.add(root.val);

        if(root.left == null && root.right == null){
            StringBuilder sb = new StringBuilder();
            for(int i = 0; i < path.size(); i++){
                if(i != 0){
                    sb.append("->");
                }
                sb.append(path.get(i));
            }
            list.add(sb.toString());
            return;
        }
        
        if(root.left != null){
            backTracing(root.left);
            path.removeLast();
        }

        if(root.right != null){
            backTracing(root.right);
            path.removeLast();
        }
    }
}
```

## 404.左叶子之和

[404. 左叶子之和 - 力扣（LeetCode）](https://leetcode.cn/problems/sum-of-left-leaves/description/)

![image-20240914112743514](算法笔记.assets/image-20240914112743514.png)

```java
class Solution {
    int count = 0;
    public int sumOfLeftLeaves(TreeNode root) {
        sum(root);
        return count;
    }


    public void sum(TreeNode root){
        if(root == null)
            return;
            
        if(root.left != null && root.left.left == null && root.left.right == null){
            count += root.left.val;
        }

        sum(root.left);
        sum(root.right);
    }
}

```

##  513.找树左下角的值

[513. 找树左下角的值 - 力扣（LeetCode）](https://leetcode.cn/problems/find-bottom-left-tree-value/description/)

![image-20240914113231142](算法笔记.assets/image-20240914113231142.png)

```java
class Solution {
    public int findBottomLeftValue(TreeNode root) {
        int left = root.val;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while(!queue.isEmpty()){
            int len = queue.size();
            for(int i = 0; i < len; i++){
                TreeNode p = queue.poll();
                if(i == 0) left = p.val;
                if(p.left != null) queue.offer(p.left);
                if(p.right != null) queue.offer(p.right);
            }
        }
        return left;
    }
}
```

## 112. 路径总和

![image-20240914114027974](算法笔记.assets/image-20240914114027974.png)

```java
class Solution {
    boolean flag = false;
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root == null) return false;
        int sum = 0;
        backTracint(root,sum,targetSum);
        return flag;
    }

    public void backTracint(TreeNode root, int sum, int targetSum){
        if(flag == true) return;

        sum += root.val;
        if(sum == targetSum && root.left == null && root.right == null)
            flag = true;

        if(root.left != null){
            backTracint(root.left,sum,targetSum);
        }

        if(root.right != null){
            backTracint(root.right,sum,targetSum);
        }

    }
}
```

和上一题类似，有点像回溯但是不用回溯

## 106.从中序与后序遍历序列构造二叉树⭐

![image-20240914132839101](算法笔记.assets/image-20240914132839101.png)

```java
class Solution {
    Map<Integer,Integer> map = new HashMap<>();
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        for(int i = 0; i < inorder.length; i++){
            map.put(inorder[i],i);
        }

        return bulild(inorder,0,inorder.length-1,postorder,0,postorder.length-1);
    }

    public TreeNode bulild(int[] inorder,int inS,int inE,int[] postorder,int postS,int postE){
        if(inS > inE || postS > postE) return null;

        int mid = postorder[postE];//后序遍历最后一个元素是根节点
        TreeNode root = new TreeNode(mid);

        int len = map.get(mid) - inS;//找到根节点在中序遍历的位置

        root.left = bulild(inorder,inS,inS + len - 1,postorder,postS,postS + len - 1);
        root.right = bulild(inorder,inS + len + 1,inE,postorder,postS + len,postE-1);

        return root;
    }

}
```

## ⭐105.从前序与中序遍历序列构造二叉树

![image-20240914134542844](算法笔记.assets/image-20240914134542844.png)

```java
class Solution {
    Map<Integer,Integer> map = new HashMap<>();
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        for(int i = 0; i < inorder.length; i++){
            map.put(inorder[i],i);
        }
        return build(inorder,0,inorder.length-1,preorder,0,preorder.length-1);
    }

    public TreeNode build(int[] inorder,int inS,int inE,int[] preorder,int preS,int preE){
        if(preS > preE || inS > inE) return null;

        int mid = preorder[preS];
        TreeNode root = new TreeNode(mid);
        int index = map.get(mid);
        int len = index - inS;

        root.left = build(inorder,inS,inS + len - 1,preorder,preS + 1,preS + len);
        root.right = build(inorder,inS + len + 1,inE,preorder,preS + len + 1,preE);
        return root;
    }

}
```

这两道题请务必自己画出来啊！！！

算数关系很复杂，头痛

而且记得要算len，不要用index

## 654.最大二叉树

[654. 最大二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-binary-tree/description/)

![image-20240914135649250](算法笔记.assets/image-20240914135649250.png)

```java
class Solution {

    public TreeNode constructMaximumBinaryTree(int[] nums) {
        return build(nums,0,nums.length-1);
    }   

    public TreeNode build(int[] nums,int start,int end){
        if(start > end) return null;

        //求最大值
        int maxIndex = start;
        for(int i = start; i <= end; i++){
            if(nums[i] > nums[maxIndex]) maxIndex = i;
        }
        
        TreeNode root = new TreeNode(nums[maxIndex]);

        root.left = build(nums,start,maxIndex-1);
        root.right = build(nums,maxIndex+1,end);
        return root;
    }
}
```

和上题类似，也是根据数组建树。

## 617.合并二叉树⭐

[617. 合并二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-two-binary-trees/description/)

![image-20240914231004323](算法笔记.assets/image-20240914231004323.png)

```java
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        return merge(root1,root2);
    }


    public TreeNode merge(TreeNode root1, TreeNode root2){
        if(root1 == null) return root2;
        if(root2 == null) return root1;

        root1.val += root2.val;
        root1.left = merge(root1.left,root2.left);
        root1.right = merge(root1.right,root2.right);

        return root1;
    }
}
```

##  700.二叉搜索树中的搜索

[700. 二叉搜索树中的搜索 - 力扣（LeetCode）](https://leetcode.cn/problems/search-in-a-binary-search-tree/description/)

![image-20240914231350034](算法笔记.assets/image-20240914231350034.png)

```java
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        while (root != null) {
            if (val < root.val) {
                root = root.left;
            } else if (val > root.val) {
                root = root.right;
            } else {
                return root;
            }
        }
        return null;
    }
}
```

## 98.验证二叉搜索树⭐

[98. 验证二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/validate-binary-search-tree/description/)

```java
class Solution {
    TreeNode pre;
    boolean flag = true;
    public boolean isValidBST(TreeNode root) {
        isTrue(root);
        return flag;
    }

    public void isTrue(TreeNode root){
        if(root == null) return;

        isTrue(root.left);

        if(pre != null && root.val <= pre.val)
            flag = false;
        pre = root;

        isTrue(root.right);
    }
}
```

二叉搜索树重要性质！！！中序遍历是递归的，可以用这条性质判断其是否是搜索树。

## 530.二叉搜索树的最小绝对差

[530. 二叉搜索树的最小绝对差 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/)

![image-20240914234525423](算法笔记.assets/image-20240914234525423.png)

```java
class Solution {
    TreeNode pre;
    int min = Integer.MAX_VALUE;

    public int getMinimumDifference(TreeNode root) {
        get(root);
        return min;
    }

    public void get(TreeNode root) {
        if(root == null) return;

        get(root.left);

        if (pre != null) {
            min = Math.min(min, root.val - pre.val);
        }
        pre = root;

        get(root.right);
    }

}
```

## 501.二叉搜索树中的众数

[501. 二叉搜索树中的众数 - 力扣（LeetCode）](https://leetcode.cn/problems/find-mode-in-binary-search-tree/description/)

![image-20240915001005122](算法笔记.assets/image-20240915001005122.png)

```java
class Solution {
    int maxCount = 0;
    int curCount = 0;
    TreeNode pre;
    List<Integer> list = new ArrayList<>();

    public int[] findMode(TreeNode root) {
        find(root);
        int[] nums = new int[list.size()];
        for(int i = 0; i < nums.length; i++){
            nums[i] = list.get(i);
        }
        return nums;
    }

    public void find(TreeNode root){
        if(root == null) return;

        findMode(root.left);

        if(pre == null){
            curCount = 1;
        }else if(pre != null && root.val == pre.val){
            curCount++;
        }else{
            curCount = 1;
        }
        pre = root;
        if(curCount == maxCount)
            list.add(pre.val);
        if(curCount > maxCount){
            list.clear();
            list.add(pre.val);
            maxCount = curCount;
        }
        findMode(root.right);
    }

}
```

## 236. 二叉树的最近公共祖先⭐⭐

[236. 二叉树的最近公共祖先 - 力扣（LeetCode）](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/)

![image-20240915002122231](算法笔记.assets/image-20240915002122231.png)

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null || root == p || root == q)
            return root;

        TreeNode left = lowestCommonAncestor(root.left,p,q);
        TreeNode right = lowestCommonAncestor(root.right,p,q);
        
        if(left == null && right == null) return null;
        else if(left != null && right == null) return left;
        else if(left == null && right != null) return right;
        else  return root;
    }   
}
```

##  235. 二叉搜索树的最近公共祖先

![image-20240915002343761](算法笔记.assets/image-20240915002343761.png)

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        
        if(root == null || root == p || root == q){
            return root;
        }

        TreeNode left = lowestCommonAncestor(root.left,p,q);
        TreeNode right = lowestCommonAncestor(root.right,p,q);

        if(left == null && right == null)
            return null;
        else if(left != null && right == null)
            return left;
        else if(left == null && right != null)
            return right;
        else
            return root;

    }
}
```

##  701.二叉搜索树中的插入操作

[701. 二叉搜索树中的插入操作 - 力扣（LeetCode）](https://leetcode.cn/problems/insert-into-a-binary-search-tree/description/)

![image-20240915003209094](算法笔记.assets/image-20240915003209094.png)

```java
class Solution {
    TreeNode pre;
    public TreeNode insertIntoBST(TreeNode root, int val) {
        if(root == null) return new TreeNode(val);
        f(root,val);
        return root;
    }

    public void f(TreeNode root,int val){
        while(root != null){
            pre = root;
            if(val < root.val)
                root = root.left;
            else if(val > root.val)
                root = root.right;
        }
        TreeNode p = new TreeNode(val);
        if(val < pre.val){
            pre.left = p;
        }else{
            pre.right = p;
        }
    }
}
```

## 450.删除二叉搜索树中的节点⭐

[450. 删除二叉搜索树中的节点 - 力扣（LeetCode）](https://leetcode.cn/problems/delete-node-in-a-bst/description/)

![image-20240915143353731](算法笔记.assets/image-20240915143353731.png)

```java
class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        if(root == null) return null;

        if(root.val == key){
            if(root.left == null && root.right == null) 
                return null;
            else if(root.left != null && root.right == null)
                return root.left;
            else if(root.left == null && root.right != null)
                return  root.right;
            else{
                TreeNode left = root.left;
                root.left = null;
                TreeNode right = root.right;
                TreeNode jilu = right;
                while(right.left != null) right = right.left;
                right.left = left;
                return jilu;
            }
        }


        if(key < root.val) root.left = deleteNode(root.left,key);
        if(key > root.val) root.right = deleteNode(root.right,key);
        
        return root;
    }
}
```

<img src="算法笔记.assets/image-20240915143502128.png" alt="image-20240915143502128" style="zoom:50%;" />

## 669. 修剪二叉搜索树⭐

[669. 修剪二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/trim-a-binary-search-tree/description/)

![image-20240915144727777](算法笔记.assets/image-20240915144727777.png)

```java
class Solution {
    public TreeNode trimBST(TreeNode root, int low, int high) {
        if(root == null) return null;
        
        if(root.val < low) return trimBST(root.right,low,high);
        if(root.val > high) return trimBST(root.left,low,high);
        // root在[low,high]范围内,但是两个子树不一定，照样要剪枝
        root.left = trimBST(root.left,low,high);
        root.right = trimBST(root.right,low,high);

        return root;
    }
}
```

##  108.将有序数组转换为二叉搜索树

[108. 将有序数组转换为二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

![image-20240915145547294](算法笔记.assets/image-20240915145547294.png)

```java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return build(nums, 0, nums.length - 1);
    }

    public TreeNode build(int nums[], int start, int end) {
        if (start > end)
            return null;

        int mid = (start + end) >> 1;
        TreeNode root = new TreeNode(nums[mid]);

        root.left = build(nums, start, mid - 1);
        root.right = build(nums, mid + 1, end);
        return root;
    }

}
```

## 538.把二叉搜索树转换为累加树

[538. 把二叉搜索树转换为累加树 - 力扣（LeetCode）](https://leetcode.cn/problems/convert-bst-to-greater-tree/description/)

![image-20240915150921596](算法笔记.assets/image-20240915150921596.png)

```java
class Solution {
    int sum = 0;

    public TreeNode convertBST(TreeNode root) {
        convert(root);
        return root;
    }

    public void convert(TreeNode root) {
        if (root == null)
            return;
        convert(root.right);

        int val = root.val;
        root.val += sum;
        sum += val;

        convert(root.left);
    }
}
```

#  回溯算法

## 回溯算法：总结篇

### **组合问题**

```java
class Solution {
    List<List<Integer>> list = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        backTracing(nums,0);
        return list;
    }

    public void backTracing(int[] nums,int index){
        //终止条件
        if(index == nums.length){
            list.add(new ArrayList<>(path));
            return; 
        }
        //横向循环！！！！
        for(int i = index; i < nums.length; i++){

            path.add(nums[i]);
            backTracing(nums,i+1);//纵向深入！！！！，如果可以重复用一个数就不用+1
            path.removeLast();
        }

    }
}
```

### 排列问题

```java
class Solution {
    List<List<Integer>> list = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    boolean used[];
    public List<List<Integer>> permute(int[] nums) {
        used = new boolean[nums.length];
        backTracing(nums);
        return list;
    }

    public void backTracing(int[] nums){
        if(path.size() == nums.length){
            list.add(new ArrayList<>(path));
            return;
        }

        for(int i = 0; i <nums.length; i++){
            if(used[i]) continue;

            used[i] = true;
            path.add(nums[i]);
            backTracing(nums);
            path.removeLast();
            used[i] = false;
        }
    }
}
```

1.要加一个used数组判断该数字是否被用过了

2.for循环要从0开始

3.不需要index了，因为有used数组判断了

### 去重方法

1.可以对集合先排序的话

![image-20240915210149732](算法笔记.assets/image-20240915210149732.png)

2.不可以对集合排序的话就用hash

![image-20240915210211304](算法笔记.assets/image-20240915210211304.png)

## 第77题. 组合

[77. 组合 - 力扣（LeetCode）](https://leetcode.cn/problems/combinations/description/)

![image-20240915153639000](算法笔记.assets/image-20240915153639000.png)

```java
class Solution {
    List<List<Integer>> list = new ArrayList<>();//存放结果列表
    List<Integer> path = new ArrayList<>();//路径列表
    public List<List<Integer>> combine(int n, int k) {
        backTracing(n,1,k);
        return list;
    }

    public void backTracing(int n,int index,int k){
        if(path.size() == k){//出口
            list.add(new ArrayList<>(path));
            return;//一定要记得获取结构要终止方法
        }
            
        for(int i = index; i <= n; i++){
            //剪枝
            //还需要k - path.size()个数字
            //还能提供 n - i + 1 个数字
            if(n - i + 1 < k - path.size())
                break;

            path.add(i);
            backTracing(n,i+1,k);
            path.removeLast();
        }
    }
}
```

注意这道题能在模板的基础上剪枝

## 216.组合总和III

![image-20240915154708030](算法笔记.assets/image-20240915154708030.png)

```java
class Solution {
    List<List<Integer>> list = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    public List<List<Integer>> combinationSum3(int k, int n) {
        backTracing(k, n, 1, 0);
        return list;
    }

    public void backTracing(int k, int n, int index, int sum) {
        if (sum == n && path.size() == k) {
            list.add(new ArrayList<>(path));
            return;
        }
        if (sum >= n) {
            return;
        }

        for (int i = index; i <= 9; i++) {
            //剪枝
            if(9 - i + 1 < k - path.size())
                break;
            sum += i;
            path.add(i);
            backTracing(k, n, i + 1, sum);
            path.removeLast();
            sum-=i;
        }
    }
}
```

## 17.电话号码的字母组合⭐⭐

[17. 电话号码的字母组合 - 力扣（LeetCode）](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/)

![image-20240915162114643](算法笔记.assets/image-20240915162114643.png)

```java、
class Solution {
    List<String> list = new ArrayList<>();
    StringBuilder sb = new StringBuilder();

    public List<String> letterCombinations(String digits) {
        if(digits == null || digits.length() == 0) return list;

        String[] str = {"","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
        backTracint(0,digits,str);
        return list;
    }

    public void backTracint(int index,String digits,String[] str){
        if(index == digits.length()){
            list.add(sb.toString());
            return;
        }

        String numString = str[digits.charAt(index) - '0'];
        for(int i = 0; i < numString.length(); i++){
            sb.append(numString.charAt(i));
            backTracint(index+1,digits,str);
            sb.deleteCharAt(sb.length()-1);
        }
    }
}
```

## 39. 组合总和⭐

[39. 组合总和 - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum/description/)

![image-20240915164610918](算法笔记.assets/image-20240915164610918.png)

```java
class Solution {
    List<List<Integer>> list = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        backTracing(candidates,target,0,0);
        return list;
    }

    public void backTracing(int[] candidates, int target,int index,int sum){
        if(sum > target) 
            return;
        if(sum == target){
            list.add(new ArrayList<>(path));
            return;
        }

        for(int i = index; i < candidates.length; i++){
            sum += candidates[i];
            path.add(candidates[i]);
            backTracing(candidates,target,i,sum);//可以重复读取，不用+1
            path.removeLast();
            sum -= candidates[i];
        }

    }
}
```

![39.组合总和](算法笔记.assets/20201223170730367.png)

## 40.组合总和II

![image-20240915170001144](算法笔记.assets/image-20240915170001144.png)

```java
class Solution {
    List<List<Integer>> list = new ArrayList<>();
    List<Integer> path = new ArrayList<>();

    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        backTracing(candidates,target,0,0);
        return list;
    }


    public void backTracing(int[] candidates, int target,int index,int sum){
        if(sum > target)
            return;
        if(sum == target){
            list.add(new ArrayList<>(path));
            return;
        }

        for(int i = index; i < candidates.length; i++){
            sum += candidates[i];
            path.add(candidates[i]);
            backTracing(candidates,target,i+1,sum);
            path.removeLast();
            sum -= candidates[i];        
            ////跳过同一树层使用过的元素
            while(i+1 < candidates.length && candidates[i] == candidates[i+1]) i++;
        }
    }
}
```

![40.组合总和II](算法笔记.assets/20230310000918.png)

## 131.分割回文串

![image-20240915171753024](算法笔记.assets/image-20240915171753024.png)

```java
class Solution {
    List<List<String>> list = new ArrayList<>();
    List<String> path = new ArrayList<>();
    public List<List<String>> partition(String s) {
        backTracing(s,0);
        return list;
    }

    public void backTracing(String s,int index){
        if(index == s.length()){
            list.add(new ArrayList<>(path));
            return;
        }

        for(int i = index; i < s.length(); i++){
            //不是回文串            
            if(!isHuiwen(s,index,i))
                continue;
            //获取回文串
            String str = s.substring(index,i+1);
            path.add(str);
            backTracing(s,i+1);
            path.removeLast();
        }
    }

    //判断是否是回文串
    public boolean isHuiwen(String s,int left, int right){
        while(left < right){
            if(s.charAt(left) != s.charAt(right)) return false;
            left++;
            right--;
        }
        return true;
    }
}
```

![131.分割回文串](算法笔记.assets/131.分割回文串.jpg)

判断是否是回文串一定要记得left++、right--，又浪费很久时间

## 93.复原IP地址

[93. 复原 IP 地址 - 力扣（LeetCode）](https://leetcode.cn/problems/restore-ip-addresses/description/)

![image-20240915174134100](算法笔记.assets/image-20240915174134100.png)

```java
class Solution {
    List<String> list = new ArrayList<>();
    List<String> path = new ArrayList<>();
    public List<String> restoreIpAddresses(String s) {
        backTracing(s,0);
        return list;
    }
    public void backTracing(String s, int index){
        if(path.size() > 4 || index > s.length()) return;
        if(index == s.length() && path.size() == 4){
            StringBuilder sb = new StringBuilder();
            for(int i = 0; i < path.size(); i++){
                sb.append(".");
                sb.append(path.get(i));
            }
            sb.deleteCharAt(0);//去掉第一个.
            list.add(sb.toString());
            return;
        }

        for(int i = index; i <s.length(); i++){
            String str = s.substring(index,i+1);
            if(!isIp(str))
                continue;

            path.add(str);
            backTracing(s,i+1);
            path.removeLast();
        }
    }
    public boolean isIp(String ip){
        if(ip.length() > 4)
            return false;
        if(ip.startsWith("0") && ip.length() != 1)
            return false; 
        int k = Integer.parseInt(ip);
        if(k >= 0 && k <= 255)
            return true;
        else
            return false;
    }
}
```

就是分割字符串

## 78.子集

[78. 子集 - 力扣（LeetCode）](https://leetcode.cn/problems/subsets/description/)

![image-20240915200218267](算法笔记.assets/image-20240915200218267.png)

```java
class Solution {
    List<List<Integer>> list = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    public List<List<Integer>> subsets(int[] nums) {
        backTracing(nums,0);
        return list;
    }

    public void backTracing(int[] nums,int index){
        list.add(new ArrayList<>(path));
        if(index == nums.length)
            return;
        
        for(int i = index; i <nums.length; i++){
            path.add(nums[i]);
            backTracing(nums,i+1);
            path.removeLast();
        }
    }
}
```

## 90.子集II

[90. 子集 II - 力扣（LeetCode）](https://leetcode.cn/problems/subsets-ii/description/)

![image-20240915201132691](算法笔记.assets/image-20240915201132691.png)

```java
class Solution {
    List<List<Integer>> list = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        backTracing(nums,0);
        return list;
    }

    public void backTracing(int[] nums,int index){
        list.add(new ArrayList<>(path));
        //终止条件
        if(index == nums.length){
            return; 
        }
        //横向循环
        for(int i = index; i < nums.length; i++){

            path.add(nums[i]);
            backTracing(nums,i+1);//纵向深入
            path.removeLast();

            while(i+1 < nums.length && nums[i] == nums[i+1]) i++;
        }

    }
}
```

 while(i+1 < nums.length && nums[i] == nums[i+1]) i++;使用这行代码跳过横向遍历相同的数字

## 491.递增子序列⭐

[491. 非递减子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/non-decreasing-subsequences/description/)

![image-20240915203807558](算法笔记.assets/image-20240915203807558.png)

```java
class Solution {
    List<List<Integer>> list = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    public List<List<Integer>> findSubsequences(int[] nums) {
        backTracing(nums,0);
        return list;
    }

    public void backTracing(int[] nums, int index){
        if(path.size() > 1) 
            list.add(new ArrayList<>(path));
        if(index == nums.length)
            return;
        Set<Integer> set = new HashSet<>();
        for(int i = index; i < nums.length; i++){
            if(!path.isEmpty() && nums[i] < path.getLast()){
                continue;
            }
            if(set.contains(nums[i]))
                continue;
            else
                set.add(nums[i]);
            path.add(nums[i]);
            backTracing(nums,i+1);
            path.removeLast();
        }
    }
}
```

hash去重，之前是用 while(i+1 < nums.length && nums[i] == nums[i+1]) i++;跳过相同数字，但是这次相同数字不挨着，或者没办法让他们挨着，因为要求序列，所以只能用hash。

## 46.全排列⭐

[46. 全排列 - 力扣（LeetCode）](https://leetcode.cn/problems/permutations/description/)

![image-20240915205118882](算法笔记.assets/image-20240915205118882.png)

```java
class Solution {
    List<List<Integer>> list = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    boolean used[];
    public List<List<Integer>> permute(int[] nums) {
        used = new boolean[nums.length];
        backTracing(nums);
        return list;
    }

    public void backTracing(int[] nums){
        if(path.size() == nums.length){
            list.add(new ArrayList<>(path));
            return;
        }

        for(int i = 0; i <nums.length; i++){
            if(used[i]) continue;

            used[i] = true;
            path.add(nums[i]);
            backTracing(nums);
            path.removeLast();
            used[i] = false;
        }
    }
}
```

全排列要加一个boolean used[]; 并且不用再写index了，因为used[]数组记录了哪些数字已经被用过，而且for循环从0开始

## 47.全排列 II

![image-20240915205802807](算法笔记.assets/image-20240915205802807.png)

```java
class Solution {
    List<List<Integer>> list = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    boolean used[];
    public List<List<Integer>> permuteUnique(int[] nums) {
        used = new boolean[nums.length];
        backTracing(nums);
        return list;
    }

    public void backTracing(int[] nums){
        if(path.size() == nums.length)
            list.add(new ArrayList<>(path));

        Set<Integer> set = new HashSet<>();
        for(int i = 0; i < nums.length; i++){
            if(used[i] || set.contains(nums[i])) continue;
            set.add(nums[i]);

            used[i] = true;
            path.add(nums[i]);
            backTracing(nums);
            path.removeLast();
            used[i] = false;
        }
    }
}
```

全排列+hahs去重

## 332.重新安排行程⭐⭐

[332. 重新安排行程 - 力扣（LeetCode）](https://leetcode.cn/problems/reconstruct-itinerary/)

```java
class Solution {
    List<String> list = new ArrayList<>();
    List<String> path = new ArrayList<>();
    boolean used[];

    public List<String> findItinerary(List<List<String>> tickets) {
        used = new boolean[tickets.size()];
        Collections.sort(tickets, (a, b) -> a.get(1).compareTo(b.get(1)));
        path.add("JFK");

        backTracing(tickets);
        return list;
    }

    public boolean  backTracing(List<List<String>> tickets) {
        if (path.size() == tickets.size() + 1) {
            list = new ArrayList<>(path);
            return true;
        }

        for (int i = 0; i < tickets.size(); i++) {
            if (!used[i] && tickets.get(i).get(0).equals(path.getLast())) {
                used[i] = true;
                path.add(tickets.get(i).get(1));
                if(backTracing(tickets)) return true;
                path.removeLast();
                used[i] = false;
            }

        }
        return false;
    }
}
```

有一个案例超时

## ⭐51. N皇后

[51. N 皇后 - 力扣（LeetCode）](https://leetcode.cn/problems/n-queens/description/)

![image-20240915224205757](算法笔记.assets/image-20240915224205757.png)

```java
class Solution {
    List<List<String>> list = new ArrayList<>();
    List<String> path = new ArrayList<>();
    char[][] nums;
    public List<List<String>> solveNQueens(int n) {
        nums = new char[n][n];
        for (char[] singleNums : nums)
            Arrays.fill(singleNums, '.');
        backTracing(n, 0);
        return list;
    }

    public void backTracing(int n, int y) {
        if (path.size() == n) {
            list.add(new ArrayList<>(path));
            return;
        }
        // 横着一行一行放
        for (int x = 0; x < n; x++) {
            if(!isTrue(x, y, n))
                continue;

            nums[x][y] = 'Q';
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < n; i++) {
                sb.append(nums[i][y]);
            }
            path.add(sb.toString());
            backTracing(n, y + 1);
            path.removeLast();
            nums[x][y] = '.';
        }
    }

    public boolean isTrue(int x, int y, int n) {
        // 竖着
        for (int k = 0; k < y; k++) {
            if (nums[x][k] == 'Q')
                return false;
        }
        // 135度
        for(int i = x-1, j = y-1; i >= 0 && j >= 0; i--,j--){
            if(nums[i][j] == 'Q')
                return false;
        }
        // 45度
        for(int i = x+1, j = y-1; i < n && j >= 0; i++,j--){
            if(nums[i][j] == 'Q')
                return false;
        }
        return true;
    }
}
```

## ⭐37. 解数独

[37. 解数独 - 力扣（LeetCode）](https://leetcode.cn/problems/sudoku-solver/description/)

![image-20240915230639204](算法笔记.assets/image-20240915230639204.png)

```java
class Solution {
    public void solveSudoku(char[][] board) {
        solveSudokuHelper(board);
    }

    private boolean solveSudokuHelper(char[][] board){
        //「一个for循环遍历棋盘的行，一个for循环遍历棋盘的列，
        // 一行一列确定下来之后，递归遍历这个位置放9个数字的可能性！」
        for (int i = 0; i < 9; i++){ // 遍历行
            for (int j = 0; j < 9; j++){ // 遍历列
                if (board[i][j] != '.'){ // 跳过原始数字
                    continue;
                }
                for (char k = '1'; k <= '9'; k++){ // (i, j) 这个位置放k是否合适
                    if (isValidSudoku(i, j, k, board)){
                        board[i][j] = k;
                        if (solveSudokuHelper(board)){ // 如果找到合适一组立刻返回
                            return true;
                        }
                        board[i][j] = '.';
                    }
                }
                // 9个数都试完了，都不行，那么就返回false
                return false;
                // 因为如果一行一列确定下来了，这里尝试了9个数都不行，说明这个棋盘找不到解决数独问题的解！
                // 那么会直接返回， 「这也就是为什么没有终止条件也不会永远填不满棋盘而无限递归下去！」
            }
        }
        // 遍历完没有返回false，说明找到了合适棋盘位置了
        return true;
    }

    /**
     * 判断棋盘是否合法有如下三个维度:
     *     同行是否重复
     *     同列是否重复
     *     9宫格里是否重复
     */
    private boolean isValidSudoku(int row, int col, char val, char[][] board){
        // 同行是否重复
        for (int i = 0; i < 9; i++){
            if (board[row][i] == val){
                return false;
            }
        }
        // 同列是否重复
        for (int j = 0; j < 9; j++){
            if (board[j][col] == val){
                return false;
            }
        }
        // 9宫格里是否重复
        int startRow = (row / 3) * 3;
        int startCol = (col / 3) * 3;
        for (int i = startRow; i < startRow + 3; i++){
            for (int j = startCol; j < startCol + 3; j++){
                if (board[i][j] == val){
                    return false;
                }
            }
        }
        return true;
    }
}
```

数独每行不只填一个，所以要x和y双层for循环

# 贪心算法

**贪心的本质是选择每一阶段的局部最优，从而达到全局最优**。 

## 455.分发饼干

[455. 分发饼干 - 力扣（LeetCode）](https://leetcode.cn/problems/assign-cookies/)

![image-20240916140543254](算法笔记.assets/image-20240916140543254.png)

```java
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);
        int i = 0;
        int j = 0;
        while(i < g.length && j < s.length){
            if(s[j] >= g[i]){//能满足条件
                i++;
                j++;
            }else{//饼干后移
                j++;
            }
        }
        return i;
    }
}
```

## 376. 摆动序列

[376. 摆动序列 - 力扣（LeetCode）](https://leetcode.cn/problems/wiggle-subsequence/description/)

![1726467641158](算法笔记.assets/1726467641158.png)

```java
class Solution {
    public int wiggleMaxLength(int[] nums) {
        int count = 1;
        int pre = 0;
        int cur = 0;
        for(int i = 1; i < nums.length; i++){
            cur = nums[i] - nums[i-1];
            if(pre == 0 && cur != 0){
                count++;
                pre = cur;
            }else if(pre > 0){
                if(cur < 0){
                    count++;
                    pre = cur;
                }else{
                    continue;
                }
            }else if(pre <0){
                if(cur > 0){
                    count++;
                    pre = cur;
                }else{
                    continue;
                }
            }
        }
        return count;
    }
}
```

## 53. 最大子序和

[53. 最大子数组和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-subarray/description/)

![image-20240916142600557](算法笔记.assets/image-20240916142600557.png)

```java
class Solution {
    public int maxSubArray(int[] nums) {
        if(nums == null) return 0;

        int max = Integer.MIN_VALUE;
        int curSum = 0;
        for(int i = 0; i <nums.length; i++){
            curSum += nums[i];
            max = Math.max(max,curSum);
            if(curSum < 0)
                curSum = 0;
        }
        return max;
    }
}
```

## 122.买卖股票的最佳时机 II

![image-20240916142742983](算法笔记.assets/image-20240916142742983.png)

```java
class Solution {
    public int maxProfit(int[] prices) {
        int sum = 0;
        for(int i = 1; i < prices.length; i++){
            sum += Math.max(prices[i] - prices[i-1],0);
        }
        return sum;
    }
}
```

## 55. 跳跃游戏

[55. 跳跃游戏 - 力扣（LeetCode）](https://leetcode.cn/problems/jump-game/description/)

![image-20240916143646675](算法笔记.assets/image-20240916143646675.png)

```java
class Solution {
    public boolean canJump(int[] nums) {

        int bigIndex = nums[0];
        for(int i = 0; i <= bigIndex; i++){
            bigIndex = Math.max(i + nums[i],bigIndex);
            if(i == nums.length - 1)
                return true;
        }
        return false;
    }
}
```

## 45.跳跃游戏 II

[45. 跳跃游戏 II - 力扣（LeetCode）](https://leetcode.cn/problems/jump-game-ii/description/)

![image-20240916144150985](算法笔记.assets/image-20240916144150985.png)

```java
class Solution {
    public int jump(int[] nums) {
        if(nums == null || nums.length == 1) return 0;
        int count = 1;
        int bigIndex = nums[0];
        int curIndex = nums[0];
        for(int i = 0; i <= curIndex; i++){
            bigIndex = Math.max(bigIndex,i + nums[i]);
            if(i == nums.length - 1)
                return count;
            if(i == curIndex){
                curIndex = bigIndex;
                count++;
            }
        }
        return count;
    }
}
```

## 1005.K次取反后最大化的数组和

[1005. K 次取反后最大化的数组和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/description/)

![image-20240916145737957](算法笔记.assets/image-20240916145737957.png)

```java
class Solution {
    public int largestSumAfterKNegations(int[] nums, int k) {
        Arrays.sort(nums);
        int i;
        for(i = 0; i < k && i < nums.length; i++){
            if(nums[i] < 0)
                nums[i] = - nums[i];
            else
                break;
        }
        int j = k - i;//剩余次数
        if(j > 0 && j % 2 != 0){
            Arrays.sort(nums);
            nums[0] = -nums[0];
        }

        //求和
        int sum = 0;
        for(int x = 0; x < nums.length; x++){
            sum += nums[x];
        }
        return sum;
    }
}
```

## 134. 加油站

[134. 加油站 - 力扣（LeetCode）](https://leetcode.cn/problems/gas-station/description/)

![image-20240916152209435](算法笔记.assets/image-20240916152209435.png)

```java
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        if(gas == null) return 0;
        //寻找积累和最小的点
        int sum = gas[0] - cost[0];
        int minSum = gas[0] - cost[0];
        int minIndex = 0;
        for(int i = 1; i < gas.length; i++){
            sum += gas[i] - cost[i];
            if(sum < minSum){
                minSum = sum;
                minIndex = i;
            }
        }
        //如果总和 < 0直接返回-1
        if(sum < 0) return -1;
        //如果最小和 > 0直接返回0   
        if(minSum >= 0) return 0;
        //从积累和最小的点往后算
        sum = 0;
        for(int i = minIndex+1; i < minIndex +1 +gas.length; i++){
            sum += gas[i % gas.length] - cost[i % gas.length];
            if(sum < 0)
                return -1;
        }
        return (minIndex + 1) % gas.length;
    }   
}
```

亏空最严重的一个点必须放在最后一步走，等着前面剩余的救助

## 135. 分发糖果

[135. 分发糖果 - 力扣（LeetCode）](https://leetcode.cn/problems/candy/description/)

![image-20240916153258812](算法笔记.assets/image-20240916153258812.png)

```java
class Solution {
    public int candy(int[] ratings) {
        int[] nums = new int[ratings.length];
        
        //从左往右分
        for(int i = 1; i < ratings.length; i++){
            if(ratings[i] > ratings[i-1])
                nums[i] = Math.max(nums[i-1]+1,nums[i]);
        }
        //从右往左分
        for(int i = ratings.length-2; i >= 0; i--){
            if(ratings[i] > ratings[i+1])
                nums[i] = Math.max(nums[i+1]+1,nums[i]);
        }

        int sum = 0;
        for(int i = 0; i < nums.length;i++){
            sum += nums[i];
        }
        return sum + nums.length;
    }
}
```

## 860.柠檬水找零

[860. 柠檬水找零 - 力扣（LeetCode）](https://leetcode.cn/problems/lemonade-change/description/)

![image-20240916153825784](算法笔记.assets/image-20240916153825784.png)

```java
class Solution {
    public boolean lemonadeChange(int[] bills) {
        int i5 = 0;
        int i10 = 0;

        for(int i = 0; i < bills.length; i++){
            if(bills[i] == 5){
                i5++;
            }else if(bills[i] == 10){
                i5--;
                i10++;
            }else{
                if(i10 != 0){
                    i10--;
                    i5--;
                }else{
                    i5-=3;
                }
            }
            if(i5 < 0)
                return false;    
        }
        return true;
    }
}
```

## 406.根据身高重建队列⭐⭐

[406. 根据身高重建队列 - 力扣（LeetCode）](https://leetcode.cn/problems/queue-reconstruction-by-height/description/)

![image-20240916161247237](算法笔记.assets/image-20240916161247237.png)

```java
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        Arrays.sort(people, (a, b) -> {
            if (b[0] == a[0])// 身高相同，前面人数少的排在前面
                return a[1] - b[1];
            return b[0] - a[0];// 按身高排序
        });

        List<int[]> list = new ArrayList<>();
        for(int[] person : people){
            list.add(person[1],person);
        }

        return list.toArray(new int[people.length][]);
    }
}
```



<img src="算法笔记.assets/image-20240916160429107.png" alt="image-20240916160429107" style="zoom: 50%;" />

## 452. 用最少数量的箭引爆气球

![image-20240916163452880](算法笔记.assets/image-20240916163452880.png)

```java
class Solution {
    public int findMinArrowShots(int[][] points) {
        Arrays.sort(points,(a,b) -> Integer.compare(a[0],b[0]));
        
        int count = 1;
        int right = points[0][1];
        for(int i = 1; i < points.length; i++){
            if(points[i][0] > right){
                count++;
                right = points[i][1];
            }else{
                right = Math.min(right,points[i][1]);
            }
        }
        return count;
    }
}
```

##  435. 无重叠区间⭐

[435. 无重叠区间 - 力扣（LeetCode）](https://leetcode.cn/problems/non-overlapping-intervals/description/)

![image-20240916170108471](算法笔记.assets/image-20240916170108471.png)

```java
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        Arrays.sort(intervals,(a,b) -> Integer.compare(a[1],b[1]));

        int count = 0;
        int right = intervals[0][1];
        for(int i = 1; i < intervals.length; i++){
            if(intervals[i][0] >= right){
                right = intervals[i][1];
            }else{
                count++;
            }
        }
        return count;    
    }
}
```

官解里对这个描述的非常清楚了，这个题其实是预定会议的一个问题，给你若干时间的会议，然后去预定会议，那么能够预定的最大的会议数量是多少？核心在于我们要找到最大不重叠区间的个数。 如果我们把本题的区间看成是会议，那么按照右端点排序，我们一定能够找到一个最先结束的会议，而这个会议一定是我们需要添加到最终结果的的首个会议。（这个不难贪心得到，因为这样能够给后面预留的时间更长）。

## 763.划分字母区间

[763. 划分字母区间 - 力扣（LeetCode）](https://leetcode.cn/problems/partition-labels/description/)

![image-20240926161005902](算法笔记.assets/image-20240926161005902.png)

```java
class Solution {
    public List<Integer> partitionLabels(String s) {
        List<Integer> list = new ArrayList<>();

        int[] nums = new int[26];
        for(int i = 0; i < s.length(); i++){
            nums[s.charAt(i) - 'a'] = i;
        }

        int right = 0;
        int left = -1;
        for(int i = 0; i < s.length(); i++){
            right = Math.max(right,nums[s.charAt(i) - 'a']);
            if(i == right){
                list.add(i-left);
                left = i;
            }
                
        }
        return list;
    }
}
```

## 56. 合并区间

![image-20240916172355722](算法笔记.assets/image-20240916172355722.png)

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        List<int[]> list = new ArrayList<>();
        Arrays.sort(intervals,(a,b) -> Integer.compare(a[0],b[0]));

        int[] temp = intervals[0];
        for(int i = 1; i < intervals.length; i++){
            if(intervals[i][0] <= temp[1]){
                temp[1] = Math.max(intervals[i][1],temp[1]);
            }else{
                list.add(temp);
                temp = intervals[i];
            }
        }
        list.add(temp);
        return list.toArray(new int[list.size()][]);
    }
}
```

这几个合并区间的题，几乎都会用到Math.max或者Math.min！！！

## 738.单调递增的数字⭐⭐

![image-20240916174504547](算法笔记.assets/image-20240916174504547.png)

```java
class Solution {
    public int monotoneIncreasingDigits(int n) {

        String str = String.valueOf(n);
        char[] s = str.toCharArray();
        
        for(int i = s.length-1; i > 0; i--){
            if(s[i] < s[i-1]){
                s[i] = '9';
                s[i-1] = --s[i-1];
            }
        }
        
        for(int i = 0; i < s.length; i++){
            if(s[i] == '9'){
                while(i+1 < s.length){
                    s[++i] = '9';
                }
            }
        }
    
        return Integer.parseInt(new String(s));
    }
}
```

反向遍历一遍 + 正向遍历一遍，因为只要有数组改到9，后面都要变成9

整型转字符串

```java
String str = String.valueOf(n);
```

## 968.监控二叉树⭐

[算法笔记 (programmercarl.com)](https://www.programmercarl.com/0968.监控二叉树.html#算法公开课)

![image-20240926164931834](算法笔记.assets/image-20240926164931834.png)

```java
class Solution {
    int count = 0;
    public int minCameraCover(TreeNode root) {
        if(search(root) == 0)
            return count+1;
        return count;
    }

    // 0 无覆盖
    // 1 有覆盖
    // 2 有摄像头
    public int search(TreeNode root){
        if(root == null)
            return 1;

        int left = search(root.left);
        int right = search(root.right);

        if(left == 0 || right == 0){
            count++;
            return 2;
        }if(left == 2 || right == 2){
            return 1;
        }else{
            return 0;
        }
    }
}
```

  **// 0 无覆盖**

  **// 1 有覆盖**

  **// 2 有摄像头**

# 单调栈

## 739. 每日温度⭐

[739. 每日温度 - 力扣（LeetCode）](https://leetcode.cn/problems/daily-temperatures/description/)

![image-20241001231122063](算法笔记.assets/image-20241001231122063.png)

```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        Deque<Integer> stack = new ArrayDeque<>();
        int[] nums = new int[temperatures.length];
        for(int i = 0; i < temperatures.length; i++){
            while(!stack.isEmpty() && temperatures[stack.peek()] < temperatures[i]){
                nums[stack.peek()] = i - stack.pop();
            }
            stack.push(i);
        }
        return nums;
    }
}
```

## 496.下一个更大元素 I⭐

[496. 下一个更大元素 I - 力扣（LeetCode）](https://leetcode.cn/problems/next-greater-element-i/description/)

![image-20240926171450909](算法笔记.assets/image-20240926171450909.png)

```java
class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        Map<Integer,Integer> map = new HashMap<>();
        Stack<Integer> stack = new Stack<>();
        stack.push(0);
        for(int i = 1; i < nums2.length; i++){
            while(!stack.isEmpty() && nums2[i] > nums2[stack.peek()]){
                map.put(nums2[stack.pop()],nums2[i]);
            }
            stack.push(i);
        }
  

        int[] res = new int[nums1.length];
        for(int i = 0; i < res.length; i++){
            res[i] = map.getOrDefault(nums1[i],-1);
        }

        return res;
    }
}
```

## 503.下一个更大元素II

[503. 下一个更大元素 II - 力扣（LeetCode）](https://leetcode.cn/problems/next-greater-element-ii/description/)

![image-20240920162624417](算法笔记.assets/image-20240920162624417.png)

```java
class Solution {
    public int[] nextGreaterElements(int[] nums) {
        int[] res = new int[nums.length];
        Arrays.fill(res,-1);
        Stack<Integer> stack = new Stack<>();
        stack.push(0);
        for(int i = 1; i < nums.length*2; i++){
            while(!stack.isEmpty() && nums[i % nums.length] > nums[stack.peek()]){
                res[stack.pop()] = nums[i % nums.length]; 
            }
            stack.push(i % nums.length);
        }
        return res;         
    }
}
```

# 动态规划基础

## 理论基础

**1. 穷举分析**

- 当台阶数是1的时候，有一种跳法，f（1） =1
- 当只有2级台阶时，有两种跳法，第一种是直接跳两级，第二种是先跳一级，然后再跳一级。即f(2) = 2;

**2. 确定边界**

通过穷举分析，我们发现，当台阶数是1的时候或者2的时候，可以明确知道青蛙跳法。f（1） =1，f(2) = 2，当台阶n>=3时，已经呈现出规律f(3) = f(2) + f(1) =3，因此f（1） =1，f(2) = 2就是青蛙跳阶的边界。

**3. 找规律，确定最优子结构**

n>=3时，已经呈现出规律 f(n) = f(n-1) + f(n-2) ，因此，f(n-1)和f(n-2) 称为 f(n) 的最优子结构。什么是最优子结构？有这么一个解释：

**4， 写出状态转移方程**

<img src="算法笔记.assets/image-20240916212909575.png" alt="image-20240916212909575" style="zoom:50%;" />

**5. 代码实现**

我们实现代码的时候，一般注意从底往上遍历哈，然后关注下边界情况，空间复杂度，也就差不多啦。动态规划有个框架的，大家实现的时候，可以考虑适当参考一下：

```java
dp[0][0][...] = 边界值
for(状态1 ：所有状态1的值){
    for(状态2 ：所有状态2的值){
        for(...){
          //状态转移方程
          dp[状态1][状态2][...] = 求最值
        }
    }
}
```

##  509. 斐波那契数

[509. 斐波那契数 - 力扣（LeetCode）](https://leetcode.cn/problems/fibonacci-number/)

![image-20240916213335092](算法笔记.assets/image-20240916213335092.png)

```java
class Solution {
    public int fib(int n) {
        if(n == 0 || n == 1) return n;
        int[] dp = new int[n+1];
        dp[0] = 0;
        dp[1] = 1;
        for(int i = 2; i <= n; i++){
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
    }
}
```

##  70. 爬楼梯

[70. 爬楼梯 - 力扣（LeetCode）](https://leetcode.cn/problems/climbing-stairs/description/)

![image-20240916213643236](算法笔记.assets/image-20240916213643236.png)

```java
class Solution {
    public int climbStairs(int n) {
        if(n == 1 || n == 2) return n;
        int[] dp = new int[n+1];
        dp[1] = 1;
        dp[2] = 2; 
        for(int i = 3; i <= n; i++){
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
    }
}
```

## 746. 使用最小花费爬楼梯

[746. 使用最小花费爬楼梯 - 力扣（LeetCode）](https://leetcode.cn/problems/min-cost-climbing-stairs/description/)

![image-20240916233441598](算法笔记.assets/image-20240916233441598.png)

```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int n = cost.length;
        int[] dp = new int[n+1];
        dp[1] = 0;
        dp[2] = Math.min(cost[0],cost[1]);
        for(int i = 3; i < n+1; i++){
            dp[i] = Math.min(dp[i-1] + cost[i-1],dp[i-2] + cost[i-2]);
        }
        return dp[n];
    }
}
```

##  62.不同路径

[62. 不同路径 - 力扣（LeetCode）](https://leetcode.cn/problems/unique-paths/description/)

![image-20240916234127229](算法笔记.assets/image-20240916234127229.png)

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];

        for(int i = 0; i < m; i++){
            dp[i][0] = 1;
        }
        for(int i = 0; i < n; i++){
            dp[0][i] = 1;
        }

        for(int i = 1; i < m; i++){
            for(int j = 1; j < n; j++){
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }

        return dp[m-1][n-1];
    }
}
```

##  63. 不同路径 II

![image-20240917000709082](算法笔记.assets/image-20240917000709082.png)

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;
        if(obstacleGrid[m-1][n-1] == 1)
            return 0;
            
        int[][] dp = new int[m][n];
        for(int i = 0; i < m; i++){
            if(obstacleGrid[i][0] == 1) break;
            dp[i][0] = 1;
        }
        for(int i = 0; i < n; i++){
            if(obstacleGrid[0][i] == 1) break;
            dp[0][i] = 1;
        }
        
        for(int i = 1; i < m; i++){
            for(int j = 1; j < n; j++){
                if(obstacleGrid[i-1][j] != 1 && obstacleGrid[i][j-1] != 1)
                    dp[i][j] = dp[i-1][j] + dp[i][j-1];
                if(obstacleGrid[i-1][j] == 1 && obstacleGrid[i][j-1] != 1)
                    dp[i][j] = dp[i][j-1];          
                if(obstacleGrid[i-1][j] != 1 && obstacleGrid[i][j-1] == 1)
                    dp[i][j] = dp[i-1][j];
            }
        }

        return dp[m-1][n-1];
    }
}
```

## 343. 整数拆分⭐

[343. 整数拆分 - 力扣（LeetCode）](https://leetcode.cn/problems/integer-break/description/)

![image-20240917002411552](算法笔记.assets/image-20240917002411552.png)

```java
class Solution {
    public int integerBreak(int n) {
        int[] dp = new int[n+1];
        
        dp[2] = 1;
        for(int i = 3; i < n+1; i++){
            for(int j = 1; j < i; j++)
                dp[i] = Math.max(dp[i],Math.max(j*(i-j),j*dp[i-j]));
        }
        return dp[n];
    }
}
```

要不拆分成两部分相乘，要不拆分成多部分相乘。

## 96.不同的二叉搜索树⭐

![image-20240917173055687](算法笔记.assets/image-20240917173055687.png)

```java
class Solution {
    public int numTrees(int n) {
        if(n == 1 || n == 2) return n;
        int[] dp = new int[n+1];
        dp[0] = 1;
        dp[1] = 1;
        for(int i = 2; i <= n; i++){
            for(int j = 1; j <= i; j++)
                //dp[j-1]是根节点为j时左边的节点可能的变化数量
                //dp[i-j]是根节点为j是右边的节点可能的变化数量
                dp[i] += dp[j-1] * dp[i-j];

        }
        return dp[n];
    }
}
```

![image-20240917173129577](算法笔记.assets/image-20240917173129577.png)

# 背包问题系列

## 01背包理论

01 背包：有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。

<img src="算法笔记.assets/image-20240917173340125.png" alt="image-20240917173340125" style="zoom: 25%;" />

### **二维数组**

题目描述：问背包能背的物品最大价值是多少？

| 重量  | 价值 |      |
| ----- | ---- | ---- |
| 物品0 | 1    | 15   |
| 物品1 | 3    | 20   |
| 物品2 | 4    | 30   |

dp数组

<img src="算法笔记.assets/image-20240917215837190.png" alt="image-20240917215837190" style="zoom: 50%;" />

1.确定dp数组以及下标的含义

```java
dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。
```

2.确定递推公式

```java
dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);// 不放物品i or 放物品i
```

3.dp数组如何初始化

```java
所有值都是从上边和左上角推出来的，所以对于i，i-1一定要初始化。
dp[0][j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。
那么很明显当 `j < weight[0]`的时候，dp[0][j] 应该是 0，因为背包容量比编号0的物品重量还小。
当`j >= weight[0]`时，dp[0][j] 应该是value[0]，因为背包容量放足够放编号0物品。
```

4.确定遍历顺序

```java
先遍历物品和先遍历背包重量都可以，因为是从左上角推理
```

<img src="算法笔记.assets/image-20240917220734323.png" alt="image-20240917220734323" style="zoom: 40%;" />

5.举例推导dp数组

<img src="算法笔记.assets/image-20240917220806903.png" alt="image-20240917220806903" style="zoom:50%;" />

### 一维数组

01背包中二维dp数组的两个for遍历的先后循序是可以颠倒了，一维dp数组的两个for循环先后循序一定是先遍历物品，再遍历背包容量，因为他从右往左遍历，如果是上下扫描填数（先背包）的话，前面都为0，没意义。

1.确定dp数组的定义

```java
在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。
```

2.一维dp数组的递推公式

```java
dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
```

3.一维dp数组如何初始化

```java
那么我假设物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了。
```

4.一维dp数组遍历顺序

```java
二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。
要知道二维数组到一维数组转换的关键点在于一维数组是在原先数组的基础上更改的,并不是像二维数组那样重新用了一行来存储新的数据,从dp[i - 1][w] ->dp[w],dp[i-1][w-wi] ->dp[w - wi]可以看出其实二维变为一维的数据主要就是要使用i-1行的数据,而对于一维数据来说就是使用上一轮的数据,所以当使用一维的数据时要确保数据是上一轮的,没有被更改的，所以需要倒序遍历！！！
```

5.举例推导dp数组

<img src="算法笔记.assets/image-20240917221916327.png" alt="image-20240917221916327" style="zoom:50%;" />

## 背包问题总结

### 递推公式

**问能否能装满背包**（或者最多装多少） ，对应题目如下：

```java
dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);//不放自己 or 放自己
```

- [动态规划：416.分割等和子集(opens new window)](https://programmercarl.com/0416.分割等和子集.html)
- [动态规划：1049.最后一块石头的重量 II](https://programmercarl.com/1049.最后一块石头的重量II.html)

**问背包装满最大价值** ，对应题目如下：

```java
dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);//不放自己 or 放自己
```

- [动态规划：474.一和零](https://programmercarl.com/0474.一和零.html)

**问装满背包有几种方法**，对应题目如下：

```java
dp[j] = dp[j] + dp[j - nums[i]] //不放自己 or 放自己，且要注意这种题要设置dp[0] = 1;
```

- [动态规划：494.目标和(opens new window)](https://programmercarl.com/0494.目标和.html)
- [动态规划：518. 零钱兑换 II(opens new window)](https://programmercarl.com/0518.零钱兑换II.html)
- [动态规划：377.组合总和Ⅳ(opens new window)](https://programmercarl.com/0377.组合总和Ⅳ.html)
- [动态规划：70. 爬楼梯进阶版（完全背包）](https://programmercarl.com/0070.爬楼梯完全背包版本.html)

**问装满背包所有物品的最小个数**，对应题目如下：

```java
dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1);//不放自己 or 放自己，且要初始化为Integer.MAX_VALUE，且dp[0] = 0;
```

- [动态规划：322.零钱兑换(opens new window)](https://programmercarl.com/0322.零钱兑换.html)
- [动态规划：279.完全平方数](https://programmercarl.com/0279.完全平方数.html)

### **容量遍历方向**

**01背包**

外层物品，内层容量，内层反向遍历从而保留状态

```java
for(int i = 0; i <stones.length; i++){
    for(int j = target; j >= stones[i]; j--)
        dp[j] = Math.max(dp[j],dp[j-stones[i]] + stones[i]);
}
```

**完全背包**

正向遍历，因为可以多次使用同一物品

```java
dp[0] = 1;
for(int i = 0; i < coins.length; i++){
    for(int j = coins[i]; j < amount + 1; j++){
        //不用当前硬币有多少种 or 用当前硬币有多少种
        dp[j] =  dp[j] + dp[j - coins[i]];
    }
}
```

### 排列组合

组合问题外层物品，内层容量，因为出现在前面的物品肯定在前面被选，所以结果是组合数

排列问题外层容量，内层物品，各个物品都可以出现在前面或者后面，所以是排列数

![img](算法笔记.assets/背包问题1.jpeg)

##  416. 分割等和子集

[416. 分割等和子集 - 力扣（LeetCode）](https://leetcode.cn/problems/partition-equal-subset-sum/description/)

![image-20240917223320966](算法笔记.assets/image-20240917223320966.png)

```java
class Solution {
    public boolean canPartition(int[] nums) {
        int sum = 0;
        for(int i = 0; i < nums.length; i++){
            sum += nums[i];
        }
        if(sum % 2 != 0) return false;

        int target = sum/2;
        int[] dp = new int[target+1];//价值和体积相同
        for(int i = 0; i < nums.length; i++){//先遍历物品
            for(int j = target; j >= nums[i]; j--){//再遍历背包
                dp[j] = Math.max(dp[j],dp[j-nums[i]] + nums[i]);
                if(dp[target] == target) return true;//稍微剪枝一下
            }
        }

        return dp[target] == target;
    }
}
```

这一题的价值和体积相同，目的是找到一半的值

## 1049.最后一块石头的重量II

[1049. 最后一块石头的重量 II - 力扣（LeetCode）](https://leetcode.cn/problems/last-stone-weight-ii/description/)

![image-20240917224002633](算法笔记.assets/image-20240917224002633.png)

```java
class Solution {
    public int lastStoneWeightII(int[] stones) {
        int sum = 0;
        for(int i = 0; i < stones.length; i++){
            sum += stones[i];
        }
        int target = sum >> 1;

        int[] dp = new int[target+1];
        for(int i = 0; i <stones.length; i++){
            for(int j = target; j >= stones[i]; j--)
                dp[j] = Math.max(dp[j],dp[j-stones[i]] + stones[i]);
        }

        return sum - 2*dp[target];
    }
}
```

##  494.目标和⭐

[494. 目标和 - 力扣（LeetCode）](https://leetcode.cn/problems/target-sum/description/)

![image-20240917231338252](算法笔记.assets/image-20240917231338252.png)

```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        if(nums == null) return 1;
        int sum = 0;
        for(int i = 0; i <nums.length; i++){
            sum += nums[i];
        }
        //sum - 2 * x = target -> x = （sum-target）/2
        if((sum - target) % 2 != 0) return 0;
        int x = (sum - target) >> 1;

        int[] dp = new int[x+1];
        dp[0] = 1;
        for(int i = 0; i < nums.length; i++){//先遍历数字
            for(int j = x; j >= nums[i]; j--)
                dp[j] = dp[j] + dp[j - nums[i]];
        }
        return dp[x];
    }
}
```

多少次的问题必须要初始化dp[0]=1，普通背包问题就不用初始化dp[0]；

**二维数组**

1.确定dp数组以及下标的含义

```java
dp[i][j]：使用 下标为[0, i]的nums[i]能够凑满j（包括j）这么大容量的包，有dp[i][j]种方法。
```

2.递推公式

```java
不放物品i：即背包容量为j，里面不放物品i，装满有dp[i - 1][j]中方法。
放物品i： 即：先空出物品i的容量，背包容量为（j - 物品i容量），放满背包有 dp[i - 1][j - 物品i容量] 种方法。
dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]];
```

3.dp数组如何初始化

<img src="算法笔记.assets/image-20240917225833079.png" alt="image-20240917225833079" style="zoom:33%;" />

```java
先明确递推的方向，如图，求解 dp[2][2] 是由上方和左上方推出，那么二维数组的最上行一定要初始化，这是递推公式推导的基础。
dp[0][j]：只放物品0， 把容量为j的背包填满有几种方法？
    只有背包容量为 物品0 的容量的时候，方法为1，正好装满。
    其他情况下，要不是装不满，要不是装不下。
    所以初始化：dp[0][nums[0]] = 1 ，其他均为0 。
但这里有例外，就是如果 物品数值就是0呢？那么dp[0][0]就要修改。
    如果有两个物品，物品0为0， 物品1为0，装满背包容量为0的方法有几种。
        放0件物品
        放物品0
        放物品1
        放物品0 和 物品1
        此时是有4种方法。
    其实就是算数组里有t个0，然后按照组合数量求，即 2^t 。
```

4.确定遍历顺序

```java
先遍历哪个都行
```

5.举例推导dp数组

<img src="算法笔记.assets/image-20240917230646423.png" alt="image-20240917230646423" style="zoom:50%;" />

## 474.一和零⭐

[474. 一和零 - 力扣（LeetCode）](https://leetcode.cn/problems/ones-and-zeroes/description/)

![image-20240917233532559](算法笔记.assets/image-20240917233532559.png)

```java
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        int[][] dp = new int[m+1][n+1];

        for(String str :strs){
            int count0 = 0;
            int count1 = 0;
            for(int i = 0; i < str.length(); i++){
                if(str.charAt(i) == '0')
                    count0++;
                else
                    count1++;
            }
            //两个维度的01背包
            //价值是字符串个数，体积是0和1的个数
            for(int i = m; i >= count0; i--){{
                for(int j = n; j >= count1; j--)
                    dp[i][j] = Math.max(dp[i][j],dp[i-count0][j-count1] + 1);
            }}
        }
        return dp[m][n];
    }
}
```

字符串的zeroNum和oneNum相当于物品的重量（weight[i]），字符串本身的个数相当于物品的价值（value[i]）。**这就是一个典型的01背包！** 只不过物品的重量有了两个维度而已。

## 完全背包理论基础

有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品都有无限个（也就是可以放入背包多次）**，求解将哪些物品装入背包里物品价值总和最大，完全背包和01背包问题唯一不同的地方就是，每种物品有无限件。

```java
我们知道01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。

而完全背包的物品是可以添加多次的，所以要从小到大去遍历。
```

```java
01背包中二维dp数组的两个for遍历的先后循序是可以颠倒了，一维dp数组的两个for循环先后循序一定是先遍历物品，再遍历背包容量。
在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序是无所谓的！
因为dp[j]是根据下标j之前所对应的dp[j]计算出来的。 只要保证下标j之前的dp[j]都是经过计算的就可以了。
```

## 518.零钱兑换II⭐

![image-20240917235619233](算法笔记.assets/image-20240917235619233.png)

```java
class Solution {
    public int change(int amount, int[] coins) {
        int[] dp = new int[amount+1];

        dp[0] = 1;
        for(int i = 0; i < coins.length; i++){
            for(int j = coins[i]; j < amount + 1; j++){
                //不用当前硬币有多少种 or 用当前硬币有多少种
                dp[j] =  dp[j] + dp[j - coins[i]];
            }
        }

        return dp[amount];
    }
}
```

## 377. 组合总和 Ⅳ

[377. 组合总和 Ⅳ - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum-iv/description/)

![image-20240919113944342](算法笔记.assets/image-20240919113944342.png)

```java
class Solution {
    public int combinationSum4(int[] nums, int target) {
        int[] dp = new int[target+1];
        dp[0] = 1;

        for(int j = 0; j <= target; j++){
            for(int i = 0; i < nums.length; i++){
                if(j >= nums[i])
                    dp[j] += dp[j-nums[i]];
            }
        }

        return dp[target];
    }
}
```

## 70. 爬楼梯（进阶版）

![image-20240919115001143](算法笔记.assets/image-20240919115001143.png)

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int m = in.nextInt();
        
        
        int[] dp = new int[n+1];
        dp[0] = 1;
        for(int j = 0; j <= n; j++){
            for(int i = 1; i <= m; i++){
                if(j >= i)
                    dp[j] += dp[j-i];
            }
        }
          
        System.out.println(dp[n]);
    }
}

```

##  322. 零钱兑换

[322. 零钱兑换 - 力扣（LeetCode）](https://leetcode.cn/problems/coin-change/description/)

![image-20240919115416336](算法笔记.assets/image-20240919115416336.png)

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int max = Integer.MAX_VALUE;
        int[] dp = new int[amount+1];
        Arrays.fill(dp,max);
        dp[0] = 0;

        for(int i = 0; i < coins.length; i++){
            for(int j = coins[i]; j <= amount; j++){
                if(dp[j-coins[i]] != max)
                    dp[j] =  Math.min(dp[j],dp[j-coins[i]]+1);
            }
        }
        return dp[amount] == max ? -1 : dp[amount];
    }
}
```

## 279.完全平方数

[279. 完全平方数 - 力扣（LeetCode）](https://leetcode.cn/problems/perfect-squares/description/)

![image-20240919115849377](算法笔记.assets/image-20240919115849377.png)

```java
class Solution {
    public int numSquares(int n) {
        int max = Integer.MAX_VALUE;
        int[] dp = new int[n+1];
        Arrays.fill(dp,max);
        dp[0] = 0;

        for(int i = 1; i*i <= n; i++){
            for(int j = i*i; j <= n; j++){
                if(dp[j-i*i] != max)
                    dp[j] = Math.min(dp[j],dp[j-i*i]+1);
            }
        }
        return dp[n] == max  ? -1 : dp[n];
    }
}
```

## 139.单词拆分⭐

![image-20240927152514703](算法笔记.assets/image-20240927152514703.png)

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        boolean[] dp = new boolean[s.length()+1];
        dp[0] = true;

        for(int j = 0; j < s.length(); j++){
            for(String str : wordDict){
                if(dp[j] == true 
                && j+str.length() <= s.length()
                && s.substring(j,j+str.length()).equals(str))
                    dp[j+str.length()] = true;
            }
        }

        return dp[s.length()];
    }
}
```

# 打家劫舍系列

##  198.打家劫舍

[198. 打家劫舍 - 力扣（LeetCode）](https://leetcode.cn/problems/house-robber/description/)

![image-20240919134355419](算法笔记.assets/image-20240919134355419.png)

```java
class Solution {
    public int rob(int[] nums) {
        if(nums == null) return 0;
        if(nums.length == 1) return nums[0];
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0],nums[1]);
        for(int i = 2; i < nums.length; i++){
            dp[i] = Math.max(dp[i-1],dp[i-2] + nums[i]);
        }
        return dp[nums.length-1];
    }
}
```

## 213.打家劫舍II

[213. 打家劫舍 II - 力扣（LeetCode）](https://leetcode.cn/problems/house-robber-ii/)

![image-20240919134906014](算法笔记.assets/image-20240919134906014.png)

```java
class Solution {
    public int rob(int[] nums) {
        if(nums == null) return 0;
        if(nums.length == 1) return nums[0];
        return Math.max(rob2(nums,0,nums.length-1),rob2(nums,1,nums.length));
    }


    public int rob2(int[] nums,int left,int right){
        if(right - left == 1) return nums[left];
        int[] dp = new int[right-left];
        dp[0] = nums[left];
        dp[1] = Math.max(nums[left],nums[left+1]);
        for(int i = 2; i < right-left; i++){
            dp[i] = Math.max(dp[i-1],dp[i-2] + nums[left+i]);
        }
        return dp[right-left-1];
    }

}
```

## 337.打家劫舍 III⭐⭐

![image-20240919141308440](算法笔记.assets/image-20240919141308440.png)

```java
class Solution {
    public int rob(TreeNode root) {
        int[] res = robAction1(root);
        //0:不偷当前节点，1：偷当前节点
        return Math.max(res[0], res[1]);
    }
    
    public int[] robAction1(TreeNode root) {
        int res[] = new int[2];
        if (root == null)
            return res;

        int[] left = robAction1(root.left);
        int[] right = robAction1(root.right);
        //不偷：Max(左孩子不偷，左孩子偷) + Max(右孩子不偷，右孩子偷)
        res[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
        //偷：左孩子不偷+ 右孩子不偷 + 当前节点偷
        res[1] = root.val + left[0] + right[0];
        return res;
    }
}
```

如果是偷当前节点，那么左右孩子就不能偷，val1 = cur->val + left[0] + right[0]; （**如果对下标含义不理解就再回顾一下dp数组的含义**）

如果不偷当前节点，那么左右孩子就可以偷，至于到底偷不偷一定是选一个最大的，所以：val2 = max(left[0], left[1]) + max(right[0], right[1]);

# 股票系列

## 121. 买卖股票的最佳时机

```java
想通这一招，搞定所有股票买卖问题，包括买卖股票的最佳时机（1,2,3,4）、含冷冻期、含手续费。

我们要跳出固有的思维模式，并不是要考虑买还是卖，而是要最大化手里持有的钱。
买股票手里的钱减少，卖股票手里的钱增加，无论什么时刻，我们要保证手里的钱最多。

我们这一次买还是卖只跟上一次我们卖还是买的状态有关。

你听懂了吗？管你听没听懂，看就完了！

我们先看前两个问题的代码，其中buy和sell都代表操作之后手里的钱。

作者：洛必达泉
链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/solutions/740596/5xing-dai-ma-gao-ding-suo-you-gu-piao-ma-j6zo/
```

[121. 买卖股票的最佳时机 - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

![image-20240919143053907](算法笔记.assets/image-20240919143053907.png)

```java
class Solution {
    public int maxProfit(int[] prices) {
        if(prices.length <= 1) return 0;
        int[][] dp = new int[prices.length][2];
        dp[0][0] = -prices[0];//持有股票
        dp[1][1] = 0;//不持有股票

        for(int i = 1; i < prices.length; i++){
            dp[i][0] = Math.max(dp[i-1][0],-prices[i]);//持有股票
            dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0] + prices[i]);//不持有股票
        }

        return dp[prices.length-1][1];
    }
}
```

## 122.买卖股票的最佳时机II

[122. 买卖股票的最佳时机 II - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/)

![image-20240919143632104](算法笔记.assets/image-20240919143632104.png)

```java
class Solution {
    public int maxProfit(int[] prices) {
        if(prices.length <= 1) return 0;

        int[][] dp = new int[prices.length][2];
        dp[0][0] = -prices[0];//持有股票
        dp[1][1] = 0;//不持有股票

        for(int i = 1; i < prices.length; i++){
            dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1] - prices[i]);//持有股票
            dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0] + prices[i]);//不持有股票
        }
        return dp[prices.length-1][1];
    }
}
```

## 123.买卖股票的最佳时机III⭐

![image-20240919144500357](算法笔记.assets/image-20240919144500357.png)

```java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        if(n <= 1) return 0;

        int[][] dp = new int[n][4];
        dp[0][0] = -prices[0];//第一次买入持有股票
        dp[0][1] = 0;//第一次卖出不持有股票
        dp[0][2] = -prices[0];//第二次买入持有股票
        dp[0][3] = 0;//第二次卖出不持有股票

        for(int i = 1; i < n; i++){
            dp[i][0] = Math.max(dp[i-1][0],0 - prices[i]);//第一次买入持有股票
            dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0] + prices[i]);//第一次卖出不持有股票
            dp[i][2] = Math.max(dp[i-1][2],dp[i-1][1] - prices[i]);//第二次买入持有股票
            dp[i][3] = Math.max(dp[i-1][3],dp[i-1][2] + prices[i]);//第二次卖出不持有股票
        }
        return dp[n-1][3];
    }
}
```

##  188.买卖股票的最佳时机IV⭐⭐

![image-20240919152324320](算法笔记.assets/image-20240919152324320.png)

```java
// 到了第四题，相信大家已经要懂了，第三题最多两次我们有2x2个状态，那么k次我们就需要kx2个状态。
// 那么我们并不需要像第三题那样真的列kx2个参数，我们只需要两个数组就可以了
class Solution {
    public int maxProfit(int k, int[] prices) {
        if(prices.length <= 1) return 0;

        int[][][] dp = new int[prices.length][k+1][2];
        for(int i = 0; i <= k; i++){
            dp[0][i][0] =  -prices[0];
        }

        for(int i = 1; i < prices.length; i++){
            for(int j = 1; j <= k; j++){
                //持有
                dp[i][j][0] = Math.max(dp[i-1][j][0],dp[i-1][j-1][1]-prices[i]);
                //不持有，先买才能卖，所以是dp[i-1][j][0]
                dp[i][j][1] = Math.max(dp[i-1][j][1],dp[i-1][j][0]+prices[i]);
            }
        }
        return dp[prices.length-1][k][1];
    }
}
```

## 309.最佳买卖股票时机含冷冻期

[309. 买卖股票的最佳时机含冷冻期 - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/)

![image-20240919193056655](算法笔记.assets/image-20240919193056655.png)

```java
class Solution {
    public int maxProfit(int[] prices) {
        if(prices.length <= 1) return 0;
        if(prices.length == 2) return Math.max(0,prices[1] - prices[0]);
        int[][] dp = new int[prices.length][2];
        dp[0][0] = -prices[0];//持有
        dp[0][1] = 0;//不持有
        dp[1][0] = Math.max(-prices[0],-prices[1]);//持有
        dp[1][1] = Math.max(0,prices[1] - prices[0]);//不持有        
        for(int i = 2;  i < prices.length; i++){
            dp[i][0] = Math.max(dp[i-1][0],dp[i-2][1] - prices[i]); //持有
            dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0] + prices[i]); //不持有
        }

        return dp[prices.length-1][1];
    }
}
```

## 714.买卖股票的最佳时机含手续费

[714. 买卖股票的最佳时机含手续费 - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/)

![image-20240919193451827](算法笔记.assets/image-20240919193451827.png)

```java
class Solution {
    public int maxProfit(int[] prices, int fee) {
        if(prices.length <= 1) return 0;

        int[][] dp = new int[prices.length][2];
        dp[0][0] =  -prices[0];//持有股票
        dp[0][1] =  0;//不持有股票

        for(int i = 1; i < prices.length; i++){
            dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1] - prices[i]);//持有股票
            dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0] + prices[i] - fee);//不持有股票
        }   
        return dp[prices.length-1][1];
    }
}
```

# 子序列系列

## 300.最长递增子序列

![image-20240919195752893](算法笔记.assets/image-20240919195752893.png)

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int[] dp = new int[nums.length];
        Arrays.fill(dp,1);
        int max = 1;
        for(int i = 1; i < nums.length; i++){
            for(int j = 0; j < i; j++){
                if(nums[i] > nums[j]){
                    dp[i] = Math.max(dp[j]+1,dp[i]);
                }
            }
            max = Math.max(max,dp[i]);
        }
        return max;
    }
}
```

## 674. 最长连续递增序列

![image-20240919200822346](算法笔记.assets/image-20240919200822346.png)

```java
class Solution {
    public int findLengthOfLCIS(int[] nums) {
        if(nums.length <= 1) return nums.length;
        int[] dp = new int[nums.length];
        Arrays.fill(dp,1);
        
        int max = 1;
        for(int i = 1; i < nums.length; i++){
            if(nums[i] > nums[i-1]) 
                dp[i] = dp[i-1]+1;
            max = Math.max(max,dp[i]);
        }
        return max;
    }
}
```

##  718. 最长重复子数组⭐⭐

![image-20240919202004024](算法笔记.assets/image-20240919202004024.png)

```java
class Solution {
    public int findLength(int[] nums1, int[] nums2) {
        int[][] dp = new int[nums1.length+1][nums2.length+1];

        int res = 0;
        for(int i = 1; i < nums1.length+1; i++){
            for(int j = 1; j < nums2.length+1; j++){
                if(nums1[i-1] == nums2[j-1])
                    dp[i][j] = dp[i-1][j-1] + 1;
                    res = Math.max(res,dp[i][j]);
            }
        }
        return res;
    }
}
```

## 1143.最长公共子序列⭐

![image-20240919205010092](算法笔记.assets/image-20240919205010092.png)

```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        //长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为dp[i][j]
        int[][] dp = new int[text1.length()+1][text2.length()+1];
        for(int i = 1; i <text1.length()+1; i++){
            for(int j = 1; j < text2.length()+1; j++){
                if(text1.charAt(i-1) == text2.charAt(j-1)){
                    dp[i][j] = dp[i-1][j-1] + 1;
                }else{
                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return dp[text1.length()][text2.length()];
    }
}
```

##  1035.不相交的线

![image-20240919205633251](算法笔记.assets/image-20240919205633251.png)

```java
class Solution {
    public int maxUncrossedLines(int[] nums1, int[] nums2) {
        int[][] dp = new int[nums1.length+1][nums2.length+1];
        
        for(int i = 1; i < nums1.length+1; i++){
            for(int j = 1; j < nums2.length+1; j++){
                if(nums1[i-1] == nums2[j-1])
                    dp[i][j] = dp[i-1][j-1] + 1;
                else
                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
            }   
        }
        return dp[nums1.length][nums2.length];
    }
}
```

## 53. 最大子序和

[53. 最大子数组和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-subarray/description/)

![image-20240919210645791](算法笔记.assets/image-20240919210645791.png)

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        int max = dp[0];

        for(int i = 1; i < nums.length; i++){
            dp[i] = Math.max(dp[i-1] + nums[i], nums[i]);
            max = Math.max(max,dp[i]);
        }
        return max;
    }
}
```

```java
class Solution {
    public int maxSubArray(int[] nums) {
        
        int maxSum = nums[0];
        int curSum = nums[0];

        for(int i = 1; i < nums.length; i++){
            curSum = Math.max(curSum,0) + nums[i];
            maxSum = Math.max(maxSum,curSum); 
        }

        return maxSum;
    }
}
```

## 392.判断子序列

![image-20240919212134704](算法笔记.assets/image-20240919212134704.png)

```java
class Solution {
    public boolean isSubsequence(String s, String t) {
        int[][] dp = new int[s.length()+1][t.length()+1];

        for(int i = 1; i < s.length()+1; i++){
            for(int j = 1; j < t.length()+1; j++){
                if(s.charAt(i-1) == t.charAt(j-1))
                    dp[i][j] = dp[i-1][j-1] + 1;
                else
                    dp[i][j] = Math.max(dp[i][j-1],dp[i-1][j]);
            }
        }
        if(dp[s.length()][t.length()] == s.length())
            return true;
        else 
            return false;
    }
}
```

**双指针法**

```java
class Solution {
    public boolean isSubsequence(String s, String t) {
        int j = 0;
        for(int i = 0; i < t.length() && j < s.length(); i++){
            if(t.charAt(i) == s.charAt(j))
                j++;
        }
        if(j == s.length())
            return true;
        return false;
    }
}
```

## ！！！115.不同的子序列⭐⭐

![image-20240919220555382](算法笔记.assets/image-20240919220555382.png)

```java
class Solution {
    public int numDistinct(String s, String t) {
        int[][] dp = new int[s.length()+1][t.length()+1];
        for(int i = 0; i < s.length(); i++)
            dp[i][0] = 1;

        for(int i = 1; i < s.length()+1; i++){
            for(int j = 1; j < t.length()+1; j++){
                if(s.charAt(i-1) == t.charAt(j-1))
                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];
                else
                    dp[i][j] = dp[i-1][j];
            }
        }

        return dp[s.length()][t.length()];
    }
}
```

[代码随想录 (programmercarl.com)](https://www.programmercarl.com/0115.不同的子序列.html#思路)

## 583. 两个字符串的删除操作⭐⭐

转换为求最长公共子序列

![image-20240919221322139](算法笔记.assets/image-20240919221322139.png)

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int[][] dp = new int[word1.length()+1][word2.length()+1];

        for(int i = 1; i < word1.length()+1; i++){
            for(int j = 1; j < word2.length()+1; j++){
                if(word1.charAt(i-1) == word2.charAt(j-1)){
                    dp[i][j] = dp[i-1][j-1] + 1;
                }else{
                    dp[i][j] =  Math.max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return word1.length() + word2.length() - 2*dp[word1.length()][word2.length()];
    }
}
```

## 72. 编辑距离⭐⭐

![image-20240919222824696](算法笔记.assets/image-20240919222824696.png)

```java
class Solution {
    public int minDistance(String word1, String word2) {
        //0到i-1的word1 最长包含多长的 0到j-1的word2
        int[][] dp = new int[word1.length()+1][word2.length()+1];
        for(int i = 0; i < word1.length()+1; i++)
            dp[i][0] = i;
        for(int j = 0; j < word2.length()+1; j++)
            dp[0][j] = j;

        for(int i = 1; i < word1.length()+1; i++){
            for(int j = 1; j < word2.length()+1; j++){
                if(word1.charAt(i-1) == word2.charAt(j-1))
                    dp[i][j] = dp[i-1][j-1];
                else
                    dp[i][j] = Math.min(dp[i-1][j-1],Math.min(dp[i-1][j],dp[i][j-1])) + 1;

            }
        }
        return dp[word1.length()][word2.length()];
    }
}
```

感觉这个定义更加准确：“dp[i][j] 代表 word1 中前 i 个字符，变换到 word2 中前 j 个字符，最短需要操作的次数；”

现在再来理解“dp[i-1][j-1] 表示替换操作，dp[i-1][j] 表示删除操作，dp[i][j-1] 表示插入操作。”

dp[i-1][j-1] (表示替换)：word1的前i-1个字符已经变换到word2的前j-1个字符的次数，说明word1的前i-1个和word2的前j-1个字符已经完成操作；那么对于word1的第i个怎么变成word2的第j个呢？这两个字符都存在，那么只能是替换了；所以dp[i][j] = dp[i-1][j-1]+1;

dp[i][j-1] (表示插入)：word1的前i个字符已经变换到word2的前j-1个字符的次数，当前word1的第i步字符已经用了，但是word2还差一个字符（因为当前只是处理了word2的前j-1个字符），那么插入一个字符就好了；所以dp[i][j] = dp[i][j-1]+1;

dp[i-1][j] (表示删除)：word1的前i-1个字符已经变换到word2的前j个字符的次数，当前word1仅用了前i-1个字符就完成了到word2的前j个字符的操作，所以word1的第i个字符其实没啥用了，那么删除操作就好了；所以dp[i][j] = dp[i-1][j]+1;

艾玛，终于搞明白了； 不知道作者怎么想出来的；TQL！！！！

## 647. 回文子串⭐⭐

[647. 回文子串 - 力扣（LeetCode）](https://leetcode.cn/problems/palindromic-substrings/)

![image-20240919224459989](算法笔记.assets/image-20240919224459989.png)

```java
class Solution {
    public int countSubstrings(String s) {
        int ans = 0;
        //最终的中心点由 2 * len - 1 个，分别是 len 个单字符和 len - 1 个双字符。
        for(int i = 0; i < 2*s.length() -1; i++){
            int left = i / 2;
            int right = i / 2 + i % 2;
            //有两种情况，left == right，right = left + 1，这两种回文中心是不一样的
            while(left >= 0 && right <= s.length()-1 && s.charAt(left) == s.charAt(right)){
                left--;
                right++;
                ans++;
            }
        }
        return ans;
    }
}
```

## 516.最长回文子序列⭐⭐

[516. 最长回文子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-palindromic-subsequence/description/)

![image-20240919231015797](算法笔记.assets/image-20240919231015797.png)

```java
class Solution {
    public int longestPalindromeSubseq(String s) {
        int[][] dp = new int[s.length()][s.length()];

        for(int i = 0; i < s.length(); i++)
            dp[i][i] = 1;
        
        for(int i = s.length()-1; i >= 0; i--){
            for(int j = i+1; j < s.length(); j++){
                if(s.charAt(i) == s.charAt(j))
                    dp[i][j] = dp[i+1][j-1] + 2;
                else
                    dp[i][j] = Math.max(dp[i+1][j],dp[i][j-1]);
            }
        }
        return dp[0][s.length()-1];
    }
}
```

# hot100

## 数字转二进制数

<img src="算法笔记.assets/image-20240928222835677.png" alt="image-20240928222835677" style="zoom:33%;" />

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        
        List<Integer> list = new ArrayList<>();
        while(n > 0){
            int k = n % 2;
            n = n / 2;
            list.add(0,k);
        }
        for(int i = 0; i < list.size(); i++){
            System.out.print(list.get(i));
        }

    }
}
```

## [234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

![image-20241001230233974](算法笔记.assets/image-20241001230233974.png)

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        //找中间节点
        while(fast != null && fast.next != null){
            fast = fast.next.next;
            slow = slow.next;
        }
        //翻转后半段
        ListNode p = slow;
        ListNode q = p.next;
        p.next = null;
        while(q != null){
            ListNode r = q.next;
            q.next = p;
            p = q;
            q = r;
        }
        //p是反转后的头结点
        while(p != null && head != null){
            if(p.val != head.val)
                return false;
            p = p.next;
            head = head.next;
        }
        return true;
    }
}
```

快慢指针！慢指针一次走一个，快指针一次走两个

## [221. 最大正方形](https://leetcode.cn/problems/maximal-square/)

![image-20241001233215805](算法笔记.assets/image-20241001233215805.png)

```java
class Solution {
    public int maximalSquare(char[][] matrix) {
        int height = matrix.length;
        int width = matrix[0].length;

        int[][] dp = new int[height+1][width+1];
        int max = 0;

        for(int i = 1; i <= height; i++){
            for(int j = 1; j <= width; j++){
                if(matrix[i-1][j-1] == '1'){
                    dp[i][j] = Math.min(dp[i-1][j-1],Math.min(dp[i-1][j],dp[i][j-1]))+1;
                    max = Math.max(max,dp[i][j]);
                }
            }
        }

        return max*max;
    }
}
```

<img src="算法笔记.assets/7cbaa9df632477ba851b16d78a89d8d5ac9821163fbec47e6b9eda8eedef77f0-221_2.png" alt="221_2.png" style="zoom: 33%;" />

```java
dp[i][j]表示以第i行和j列为右下角的正方形的最大边长。
当到达(i,j)的时候，我们如何计算以(i,j)为根据点最大的正方形面积呢？
假设我们已经知道了绿色、红色、蓝色的面积了。按照我们之前的思路：
绿色已经是一个正方形了，那只需看红色与蓝色了，这里我们发现红色的边长比较短。也就说明其实以(i,j)为根据点最大的正方形的边长最远就到红色的那里。
例子上是红色的最短，如果绿色的最短呢？蓝色的最短呢？现在我们明白了，这里以(i,j)为根据点最大的正方形的边长取决于红色蓝色绿色边长最短的那一个。这里有一点木桶原理的意思。
    
dp[i−1][j−1]表示绿色的正方形
dp[i−1][j]表示红色的正方形
dp[i][j−1]表示蓝色的正方形
```

最大正方形

## [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

![image-20241002210616418](算法笔记.assets/image-20241002210616418.png)

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        List<Integer> list = new ArrayList<>();
        for(int i = 0; i < nums.length; i++){
            list.add(nums[i]);
        }
        return search(list,k);
    }
    public int search(List<Integer> list,int k){
        Random rand = new Random();
        int pivot = list.get(rand.nextInt(list.size()));

        List<Integer> small = new ArrayList<>();
        List<Integer> equal = new ArrayList<>();
        List<Integer> big  = new ArrayList<>();

        for(int i = 0; i < list.size(); i++){
            if(list.get(i) > pivot)
                big.add(list.get(i));
            else if(list.get(i) < pivot)
                small.add(list.get(i));
            else
                equal.add(list.get(i));
        }
        // 第 k 大元素在 big 中，递归划分
        if(big.size() >= k)
            return search(big,k);
        // 第 k 大元素在 small 中，递归划分
        else if(big.size() + equal.size() < k)
            return search(small,k-big.size()-equal.size());
        // 第 k 大元素在 equal 中，直接返回 pivot
        else
            return pivot;
    }
}
```

```java
快速排序的核心包括“哨兵划分” 和 “递归” 。

哨兵划分： 以数组某个元素（一般选取首元素）为基准数，将所有小于基准数的元素移动至其左边，大于基准数的元素移动至其右边。
递归： 对 左子数组 和 右子数组 递归执行 哨兵划分，直至子数组长度为 1 时终止递归，即可完成对整个数组的排序。
下图展示了数组 [2,4,1,0,3,5] 的快速排序流程。

作者：Krahets
链接：https://leetcode.cn/problems/kth-largest-element-in-an-array/solutions/2361969/215-shu-zu-zhong-de-di-k-ge-zui-da-yuan-d786p/
```

<img src="算法笔记.assets/1612615552-rifQwI-Picture1.png" alt="Picture1.png" style="zoom: 33%;" />

然而，对于包含大量重复元素的数组，每轮的哨兵划分都可能将数组划分为长度为 1 和 n−1 的两个部分，这种情况下快速排序的时间复杂度会退化至 O(N方) 。

一种解决方案是使用「三路划分」，即每轮将数组划分为三个部分：小于、等于和大于基准数的所有元素。这样当发现第 k 大数字处在“等于基准数”的子数组中时，便可以直接返回该元素。

## [208. 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/)

![image-20241002211508773](算法笔记.assets/image-20241002211508773.png)

```java
class Node{
    Node[] children;     // 子节点列表
    boolean isEnd;       // 标记是否尾节点

    public Node(){
        children = new Node[26];
        isEnd = false;
    }
}

class Trie {
    private Node root;     // 根节点

    public Trie() {
        root = new Node();
    }
    
    public void insert(String word) {
        Node node = root;      // 从根节点开始构造这个word对应的路径节点
        int n = word.length();
        for(int i = 0; i < n; i++){
            // 将当前字符添加到当前节点对应的子节点位置，然后递归更新
            int id = word.charAt(i) - 'a'; 
            if(node.children[id] == null){
                node.children[id] = new Node();
            }
            node = node.children[id];
        }
        node.isEnd = true; // 最后一个节点的isEnd置为true，表示一个完整的字符串
    }
    
    public boolean search(String word) {
        Node node = searchPrefix(word);
        return node != null && node.isEnd;  // 返回不为空且节点标记为尾节点，则包含word这个完整的字符串

    }
    
    public boolean startsWith(String prefix) {
        return searchPrefix(prefix) != null; // 返回不为空，则包含了prefix前缀
    }
    
    /**
     * 查找字典树是否包含word前缀
    */
    private Node searchPrefix(String word){
        Node node = root;  // 从根节点依次开始匹配每个字符
        int n = word.length();
        for(int i = 0; i < n; i++){
            node = node.children[word.charAt(i) - 'a']; // 根据当前字符获取对应的子节点
            if(node == null){
                return null;     // 只要当前节点为空，则不包含这个字符串，直接返回空指针
            }
        }
        return node;    // 否则匹配成功返回node
    }   
}

```

作者：画图小匠

https://leetcode.cn/problems/implement-trie-prefix-tree/solutions/2614334/javapython3cdfsbiao-zhi-wei-gou-zao-zi-d-zxrc/

![image-20240302095546093.png](算法笔记.assets/1709344595-HaJKeO-image-20240302095546093.png)

## [207. 课程表](https://leetcode.cn/problems/course-schedule/)

![image-20241002222816439](算法笔记.assets/image-20241002222816439.png)

```java
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        List<List<Integer>> list = new ArrayList<>();//存放邻接关系
        int[] ans = new int[numCourses];//存放入度
        Queue<Integer> queue = new LinkedList<>();//存放入度为0的课程
        //初始化集合
        for(int i = 0; i < numCourses; i++){
            list.add(new ArrayList<>());
        }
        //存放所有依赖关系，并调整入度
        for(int i = 0; i < prerequisites.length; i++){
            list.get(prerequisites[i][1]).add(prerequisites[i][0]);
            ans[prerequisites[i][0]]++;
        }
        //入度为0的添加到队列中
        for(int i = 0; i < numCourses; i++){
            if(ans[i] == 0){
                queue.offer(i);
            }
        }
      
        while(!queue.isEmpty()){
            int k = queue.poll();
            numCourses--;
            List<Integer> path = list.get(k);
            for(int i = 0; i < path.size(); i++){
                ans[path.get(i)]--;
                if(ans[path.get(i)] == 0){
                    queue.offer(path.get(i));
                }
            }
        }
        return numCourses == 0;
    }
}
```

## [200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)

![image-20241002224242173](算法笔记.assets/image-20241002224242173.png)

```java
class Solution {
    public int numIslands(char[][] grid) {
        int count = 0;        
        for(int i = 0; i < grid.length; i++){
            for(int j = 0; j < grid[0].length; j++){
                if(grid[i][j] == '1'){
                    dfs(grid,i,j);
                    count++;
                }
            }
        }
        return count;
    }

    public void dfs(char[][] grid,int i, int j){
        if(i<0||j<0||i==grid.length||j==grid[0].length||grid[i][j] == '0') return;
        grid[i][j] = '0';
        dfs(grid,i-1,j);
        dfs(grid,i+1,j);
        dfs(grid,i,j-1);
        dfs(grid,i,j+1);
    }
}
```

深度搜索遍历，找到一个岛屿，将连接的岛屿全部设置为海洋。

## [169. 多数元素](https://leetcode.cn/problems/majority-element/)

![image-20241002231847564](算法笔记.assets/image-20241002231847564.png)

```java
class Solution {
    public int majorityElement(int[] nums) {
        int cand_num = nums[0], count = 1;
        for (int i = 1; i < nums.length; ++i) {
            if (cand_num == nums[i])
                ++count;
            else{
                --count;
                if(count == 0){
                    cand_num = nums[i];
                    count = 1;
                }
            }
        }
        return cand_num;
    }
}
```

推论一： 若记 众数 的票数为 +1 ，非众数 的票数为 −1 ，则一定有所有数字的 票数和 >0 。

推论二： 若数组的前 a 个数字的 票数和 =0 ，则 数组剩余 (n−a) 个数字的 票数和一定仍 >0 ，即后 (n−a) 个数字的 众数仍为 x 。

作者：Krahets
链接：https://leetcode.cn/problems/majority-element/solutions/2362000/169-duo-shu-yuan-su-mo-er-tou-piao-qing-ledrh/

## [238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)

![image-20241002233630542](算法笔记.assets/image-20241002233630542.png)

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int[] res = new int[nums.length];
        res[0] = 1;
        for(int i = 1; i < nums.length; i++){
            res[i] = nums[i-1] * res[i-1];
        }
        int temp = 1;
        for(int i = nums.length-2; i >= 0; i--){
            temp = temp * nums[i+1];
            res[i] *= temp;
        }
        return res;
    }
}
```

![image-20241002233445137](算法笔记.assets/image-20241002233445137.png)

## [155. 最小栈](https://leetcode.cn/problems/min-stack/)

![image-20241003201619181](算法笔记.assets/image-20241003201619181.png)

```java
class MinStack {
    Deque<int[]> queue;
    public MinStack() {
        queue = new LinkedList<>();
    }
    public void push(int val) {
        int[] path = new int[2];
        path[0] = val;
        if(queue.isEmpty()){
            path[1] = val;
        }else{
            path[1] = Math.min(val,queue.peek()[1]);
        }
        queue.push(path);
    }
    public void pop() {
        queue.pop();
    }
    public int top() {
        return queue.peek()[0];
    }
    public int getMin() {
        return queue.peek()[1];
    }
}
```

可以用一个栈，这个栈同时保存的是每个数字 x 进栈的时候的值 与 插入该值后的栈内最小值。即每次新元素 x 入栈的时候保存一个元组：（当前值 x，栈内最小值）。

作者：负雪明烛
链接：https://leetcode.cn/problems/min-stack/solutions/242861/zui-yi-dong-yi-ge-zhan-tong-shi-bao-cun-dang-qian-/

## [152. 乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/)

![image-20241003203611485](算法笔记.assets/image-20241003203611485.png)

```java
class Solution {
    public int maxProduct(int[] nums) {
        int imax = nums[0];
        int imin = nums[0];
        int max = nums[0];

        for(int i = 1;  i < nums.length; i++){
            int pre = imax;
            imax = Math.max(nums[i],Math.max(nums[i]*imax,nums[i]*imin));
            imin = Math.min(nums[i],Math.min(nums[i]*pre,nums[i]*imin));

            max = Math.max(imax,max);
        }
        return max;
    }
}
```

dp算法，但是由于只需要前一个元素，所以直接用变量即可，要同时保存最大最小值，因为最小值也可能因为乘上nums【i】变成最大值

## [148. 排序链表](https://leetcode.cn/problems/sort-list/)

![image-20241003210025128](算法笔记.assets/image-20241003210025128.png)

```java
class Solution {
    public ListNode sortList(ListNode head) {
        if(head == null || head.next == null) return head;//单个元素不用排序
        // 使用快慢指针，寻找中间节点（涉及题目《876. 链表的中间结点》）
        ListNode fast = head.next,slow = head;
        while(fast != null && fast.next != null){
            fast = fast.next.next;
            slow = slow.next;
        }
        ListNode p = slow.next;
        slow.next = null;

        ListNode left =  sortList(head);
        ListNode right = sortList(p);
        // 合并有序链表（涉及题目《21. 合并两个有序链表》）
        return merge(left,right);
    }
    public ListNode merge(ListNode left,ListNode right){
        ListNode dummy = new ListNode();
        ListNode cur = dummy;
        while(left != null && right != null){
            if(left.val < right.val){
                cur.next = left;
                left = left.next;
            }else{
                cur.next = right;
                right = right.next;
            }
            cur = cur.next;
        }
        if(left != null){
            cur.next = left;
        }else{
            cur.next = right;
        }

        return dummy.next;
    }
}
```

## [912. 排序数组](https://leetcode.cn/problems/sort-an-array/)（归并）

![image-20241003214751247](算法笔记.assets/image-20241003214751247.png)

```java
class Solution {
    public int[] sortArray(int[] nums) {
        return merge(nums,0,nums.length-1);
    }

    public int[] merge(int[] nums,int left,int right){
        if(left == right) return new int[]{nums[left]};

        int mid = (left + right) / 2;
        int[] leftArr = merge(nums,left,mid);
        int[] rightArr = merge(nums,mid+1,right);

        int[] res = new int[right-left+1];
        int i = 0, j = 0, k = 0;
        while(i < leftArr.length && j < rightArr.length){
            res[k++] = leftArr[i] < rightArr[j] ? leftArr[i++] : rightArr[j++];
        }
        while(i < leftArr.length)
            res[k++] = leftArr[i++];
        while(j < rightArr.length)
            res[k++] = rightArr[j++];

        return res;
    }
}
```

## [146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)

![image-20241003222830668](算法笔记.assets/image-20241003222830668.png)

```java
//定义Node节点
class Node{
    int key;
    int value;
    Node pre;
    Node next;
    Node(int key,int value){
        this.key = key;
        this.value = value;
    }
}

class LRUCache {
    Node head;//增加两个哨兵节点减少判空
    Node tail;
    Map<Integer,Node> map;
    int capacity;
    public LRUCache(int capacity) {
        this.capacity = capacity;
        map = new HashMap<>(); 
        head = new Node(-1,-1);
        tail = new Node(-1,-1);
        head.next = tail;
        tail.pre = head;
    }
    
    public int get(int key) {
        if(map.containsKey(key)){
            Node node = map.get(key);
            refresh(node);
            return node.value;
        }
        return -1;
    }
    
    public void put(int key, int value) {
        Node node = null;
        if(map.containsKey(key)){
            node = map.get(key);
            node.value = value;
        }else{
            if(map.size() == capacity){
                node = tail.pre;
                map.remove(node.key);
                delete(node);
            }
            node = new Node(key,value);
            map.put(key,node);
        }
        refresh(node);
    }

    // refresh 操作分两步：
    // 1. 先将当前节点从双向链表中删除（如果该节点本身存在于双向链表中的话）
    // 2. 将当前节点添加到双向链表头部
    public void refresh(Node node){
        delete(node);
        node.next = head.next;
        head.next.pre = node;
        node.pre = head;
        head.next = node;
    }
    // 由于我们预先建立 head 和 tail 两位哨兵，
    //因此如果 node.pre 不为空，则代表了 node 本身存在于双向链表（不是新节点）
    public void delete(Node node){
        if(node.pre != null){
            node.pre.next = node.next;
            node.next.pre = node.pre;
        }
    }
}
```

## [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)

![image-20241003224438180](算法笔记.assets/image-20241003224438180.png)

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        if(head == null || head.next == null) return false;

        ListNode fast = head.next.next;
        ListNode slow = head.next;
        while(slow != fast && fast != null && fast.next != null){
            fast = fast.next.next;
            slow = slow.next;
        }
        if(fast == slow) return true;
        return false;
    }
}
```

## [136. 只出现一次的数字](https://leetcode.cn/problems/single-number/)

![image-20241003231639635](算法笔记.assets/image-20241003231639635.png)

```java
class Solution {
    public int singleNumber(int[] nums) {
        int x = 0;
        for(int n : nums){
            x ^= n;
        }
        return x;
    }
}
```

<img src="算法笔记.assets/image-20241003231652542.png" alt="image-20241003231652542" style="zoom:50%;" />

## [128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)

![image-20241005232151688](算法笔记.assets/image-20241005232151688.png)

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        if(nums == null || nums.length == 0) return 0;

        Set<Integer> set = new HashSet<>();
        for(int num : nums)
            set.add(num);
            
        int max = 1;
        int curMax = 1;
        for(int num : set){
            if(!set.contains(num-1)){
                curMax = 1;
                while(set.contains(++num)) curMax++;
                max = Math.max(max,curMax);
            }
        }
        return max;
    }
}
```

<img src="算法笔记.assets/image-20241005231459414.png" alt="image-20241005231459414" style="zoom:67%;" />

搞不懂为啥遍历set反而比nums数组快

## [124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)

![image-20241005233922343](算法笔记.assets/image-20241005233922343.png)

```java
class Solution {
    int ans = Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
        dfs(root);
        return ans;
    }
    //链：从叶子到当前节点的路径。其节点值之和是 dfs 的返回值。
    //直径：等价于由两条（或者一条）链拼成的路径。我们枚举每个 node，假设直径在这里 「拐弯」，也就是计算由左右两条从叶子到 node 的链的节点值之和，去更新答案的最大值。
    public int dfs(TreeNode root){
        if(root == null)
            return 0;

        int left = dfs(root.left);// 左子树最大链和
        int right = dfs(root.right);// 右子树最大链和
        ans = Math.max(ans,left+right+root.val);// 两条链拼成路径,在当前节点拐弯

        return Math.max(0,Math.max(left,right)+root.val);//当前子树最大单链，不拐弯
    }

}
```

## [461. 汉明距离](https://leetcode.cn/problems/hamming-distance/)

![image-20241006165644732](算法笔记.assets/image-20241006165644732.png)

```java
class Solution {
    public int hammingDistance(int x, int y) {
        int count = 0;
        int k,j;
        while(x > 0 && y > 0){
            k = x % 2;
            j = y % 2;
            x = x / 2;
            y =  y / 2;
            if(k != j)
                count++;
        }
        while(x > 0){
            k = x % 2;
            x = x / 2;
            if(k!=0)
                count++;
        }
        while(y > 0){
            j = y % 2;
            y = y / 2;
            if(j!=0)
                count++;
        }
        return count;
    }
}
```

三叶答案

```java
class Solution {
    public int hammingDistance(int x, int y) {
        int count = 0;
        for(int i = 0; i < 32; i++){
            int a = x >> i & 1,b = y >> i & 1;
            count += a^b;
        }
        return count;
    }
}
```

## [448. 找到所有数组中消失的数字](https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/)

![image-20241006192119265](算法笔记.assets/image-20241006192119265.png)

```java
class Solution {
    public List<Integer> findDisappearedNumbers(int[] nums) {
        List<Integer> list = new ArrayList<>();

        for(int i = 0; i < nums.length; i++){
            if(nums[Math.abs(nums[i])-1] > 0)
                nums[Math.abs(nums[i])-1] *= -1;
        }
        for(int i = 0; i < nums.length; i++){
            if(nums[i] > 0)
                list.add(i+1);
        }
        return list;
    }
}
```

![image-20241006192147036](算法笔记.assets/image-20241006192147036.png)

## [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

![image-20241006201323861](算法笔记.assets/image-20241006201323861.png)

```java
class Solution {
    public String minWindow(String s, String t) {
        Map<Character,Integer> need = new HashMap<>();
        for(int i = 0; i < t.length(); i++)
            need.put(t.charAt(i),need.getOrDefault(t.charAt(i),0)+1);

        Map<Character,Integer> window = new HashMap<>();
        int left = 0;//左边界
        int right = 0;//右边界
        int valid = 0;//满足条件个数
        int start = 0;//开始位置
        int len = Integer.MAX_VALUE;//长度

        while(right < s.length()){
            char c = s.charAt(right);
            right++;
            if(need.containsKey(c)){
                window.put(c,window.getOrDefault(c,0)+1);
                if(window.get(c).equals(need.get(c)))
                    valid++;
            }
            while(valid == need.size()){
                if(right - left < len){
                    start = left;
                    len = right - left;
                }
                char b = s.charAt(left);
                left++;
                if(window.containsKey(b)){
                    if(window.get(b).equals(need.get(b)))
                        valid--;
                    window.put(b,window.get(b)-1);
                }
            }
            
        }
        return len == Integer.MAX_VALUE ? "" : s.substring(start,start+len);
    }
}
```

框架！！！

```java
/* 滑动窗口算法框架 */
void slidingWindow(string s, string t) {
    unordered_map<char, int> need, window;
    for (char c : t) need[c]++;
    
    int left = 0, right = 0;
    int valid = 0; 
    while (right < s.size()) {
        // c 是将移入窗口的字符
        char c = s[right];
        // 右移窗口
        right++;
        // 进行窗口内数据的一系列更新
        ...

        /*** debug 输出的位置 ***/
        printf("window: [%d, %d)\n", left, right);
        /********************/
        
        // 判断左侧窗口是否要收缩
        while (window needs shrink) {
            // d 是将移出窗口的字符
            char d = s[left];
            // 左移窗口
            left++;
            // 进行窗口内数据的一系列更新
            ...
        }
    }
}
作者：labuladong
链接：https://leetcode.cn/problems/find-all-anagrams-in-a-string/solutions/9749/hua-dong-chuang-kou-tong-yong-si-xiang-jie-jue-zi-/
```

## [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

![image-20241006202256362](算法笔记.assets/image-20241006202256362.png)

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> res = new ArrayList<>();
        Map<Character,Integer> need = new HashMap<>();
        Map<Character,Integer> window = new HashMap<>();
        for(int i = 0; i < p.length(); i++)
            need.put(p.charAt(i),need.getOrDefault(p.charAt(i),0)+1);

        int left = 0;
        int right = 0;
        int valid = 0;
        while(right < s.length()){
            char a = s.charAt(right);
            right++;
            if(need.containsKey(a)){
                window.put(a,window.getOrDefault(a,0)+1);
                if(window.get(a).equals(need.get(a)))
                    valid++;
            }
            while(valid == need.size()){
                if(right - left == p.length())
                    res.add(left);
                char b = s.charAt(left);
                left++;
                if(window.containsKey(b)){
                    if(window.get(b).equals(need.get(b)))
                        valid--;
                    window.put(b,window.get(b)-1);
                }
            }
        }
        return res;
    }
}
```

## [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)![image-20241006205841868](算法笔记.assets/image-20241006205841868.png)

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Map<Character,Integer> map = new HashMap<>();
        int left = 0;
        int max = 0;
        for(int right = 0; right < s.length(); right++){
            char a = s.charAt(right);
            //如果当前字符已经存在于map中，且其索引位置大于等于当前left
            //这一步很重要！！！
            if(map.containsKey(a) && map.get(a) >= left){
                left = map.get(a)+1;
            }
            map.put(a,right);
            max = Math.max(max,right-left+1);
        }
        return max;
    }
}
```

## [437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)

![image-20241007144422901](算法笔记.assets/image-20241007144422901.png)

```java
class Solution {
    // 记录当前路径上出现的前缀和以及数量
    private Map<Long, Integer> preSumCount = new HashMap<>();  
    public int pathSum(TreeNode root, int targetSum) {
        preSumCount.put(0L, 1);// 有一个默认的前缀和0
        return dfs(root, targetSum, 0);// 从根节点开始搜索
    }

    private int dfs(TreeNode node, int targetSum, long preSum){
        if(node == null)return 0;       // 空节点，满足条件路径数为0
        preSum += node.val;             // 更新节点和
        // 从哈希表中获取能和preSum配对的前缀和个数
        int pathCnt = preSumCount.getOrDefault(preSum - targetSum, 0);
        // 将当前前缀和加入哈希表
        preSumCount.put(preSum, preSumCount.getOrDefault(preSum, 0 ) + 1);
        // 递归处理左右子树
        pathCnt += dfs(node.left, targetSum, preSum) + dfs(node.right, targetSum, preSum);
        // 这个节点所在的路径都处理完了，这个前缀和也就没用了
        preSumCount.put(preSum, preSumCount.get(preSum) - 1);  
        // 返回总路径数
        return pathCnt;
    }
}
```

## [399. 除法求值](https://leetcode.cn/problems/evaluate-division/)

![image-20241007151814922](算法笔记.assets/image-20241007151814922.png)

```java
class Solution {
    // 记录边 String是起始节点 Map<String,Double>是到达节点和值
    Map<String,Map<String,Double>> edges = new HashMap<>();
    // 记录访问过的字符串
    Set<String> visited = new HashSet<>();
    // 记录结果
    double[] res;

    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
        // 存储边
        for(int i = 0; i < equations.size(); ++i) {
            String s = equations.get(i).get(0);
            String t = equations.get(i).get(1);

            Map<String,Double> valueS = edges.getOrDefault(s, new HashMap<>());
            Map<String,Double> valueT = edges.getOrDefault(t, new HashMap<>());

            valueS.put(t, values[i]);
            valueT.put(s, 1/values[i]);
            
            edges.put(s, valueS);
            edges.put(t, valueT);
        }

        // 初始化结果数组
        res = new double[queries.size()];
        Arrays.fill(res, -1);
        // 进行查询
        for(int i = 0; i < queries.size(); ++i) {
            String u = queries.get(i).get(0);
            String v = queries.get(i).get(1);
            dfs(1, u, v, i);

            // 重置visited 
            visited.clear();//别忘了！！！！！！！！！！！！！！！！！！！！！！！！！！
        }

        return res;
    }
    // 深度优先遍历函数
    public void dfs(double mul, String cur, String des, int index) {
        // 遍历过的节点不需要删除
        visited.add(cur);//别忘了！！！！！！！！！！！！！！！！！！！！！！！！！！

        if(edges.containsKey(cur)) {
            // 访问到目的节点时，更新res数组
            if(cur.equals(des)) {
                res[index] = mul;
                return;
            }
            // 获取当前节点对应的哈希表
            Map<String,Double> value = edges.get(cur);
            for(String next:value.keySet()) {
                // 对没有访问过的节点进行访问
                if(!visited.contains(next)) {
                    dfs(mul * value.get(next), next, des, index);
                }
            }
        }
    }
}
```

## [394. 字符串解码](https://leetcode.cn/problems/decode-string/)

![image-20241007162558359](算法笔记.assets/image-20241007162558359.png)

```java
class Solution {
    public String decodeString(String s) {
        /*
        双栈，一个栈模拟数字，一个栈模拟字符串
         */
        Stack<Integer> numStack = new Stack<>();
        Stack<String> stringStack = new Stack<>();

        int num = 0;
        String curString = "";

        for (int i = 0; i < s.length(); i++) {
            //当前字符
            char c = s.charAt(i);

            //如果是数字
            if(Character.isDigit(c)){
                num = num * 10 + c-'0';
            } else if (c == '[') {
                //如果是左括号，就把当前数字和字符入栈,同时重置当前数字和当前字符串
                numStack.push(num);
                stringStack.push(curString);
                num = 0;
                curString = "";
            } else if (c == ']') {
                //如果是右括号，就进行解码
                //1、得到当前字符串要重复的次数，也就是[]前的数字
                int loopTimes = numStack.pop();
                //注意这里创建的是栈顶元素的string容器
                StringBuilder temp = new StringBuilder(stringStack.pop());
                for (int j = 0; j < loopTimes; j++) {
                    temp.append(curString);
                }
                curString = temp.toString();
            }else {
                //如果是字母就更新当前字母
                curString += c;
            }
        }
        return curString;
    }
}
```

## [338. 比特位计数](https://leetcode.cn/problems/counting-bits/)

![image-20241007170425575](算法笔记.assets/image-20241007170425575.png)

```java
class Solution {
    public int[] countBits(int n) {
        int[] dp = new int[n+1];
        dp[0] = 0;
        for(int i = 1; i <= n; i++){
            if(i % 2 == 1)
                dp[i] = dp[i-1]+1;
            else
                dp[i] = dp[i/2];
        }
        return dp;
    }
}
```

<img src="算法笔记.assets/image-20241007170438419.png" alt="image-20241007170438419" style="zoom: 80%;" />

## [312. 戳气球](https://leetcode.cn/problems/burst-balloons/)













































































































































## 













































​	
